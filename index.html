<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, linzx" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="linzx">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="linzx">
<meta property="og:description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linzx">
<meta name="twitter:description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>linzx</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?93e1e7523d9fccc42d9201ace7ca982a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">linzx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/js中数组的原生方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/js中数组的原生方法/" itemprop="url">js中数组的原生方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T23:47:44+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/03/js中数组的原生方法/" class="leancloud_visitors" data-flag-title="js中数组的原生方法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  5,787
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  23
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>数组应该是我们在写程序中应用到最多的数据结构了，相比于无序的对象，有序的数组帮我们在处理数据时，实在是帮了太多的忙了。今天刚好看到一篇Array.include的文章，忽然发现经过几个ES3,ES5,ES6,ES7几个版本的更迭，发现在代码中用到了好多数组的方法，所以准备全部列出来，也是给自己加深印象</p>
</blockquote>
<h2 id="1-ES3中的数组方法"><a href="#1-ES3中的数组方法" class="headerlink" title="1 ES3中的数组方法"></a>1 ES3中的数组方法</h2><ul>
<li>ES3兼容现在所有主流浏览器</li>
</ul>
<p>ES3中的方法毫无疑问大家已经烂熟在心了，不过中间有些细节可以回顾加深一下记忆，比如是否修改原数组返回新数组，执行方法之后的返回值是什么，某些参数的意义是否搞混等等。熟悉的的可以直接快速浏览或者跳过。</p>
<h3 id="1-1-join-方法"><a href="#1-1-join-方法" class="headerlink" title="1.1 join()方法"></a>1.1 join()方法</h3><p>Array.join()方法是将一个数组里面的所有元素转换成字符串，然后再将他们连接起来<strong>返回一个新数组</strong>。可以传入一个可选的字符串来分隔结果字符串中的所有元素。如果没有指定分隔字符串，就默认使用逗号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a  = [1,2,3,4,5,6,7];</div><div class="line">let b = a.join();    // b = &quot;1,2,3,4,5,6,7&quot;;</div><div class="line">let c = a.a.join(&quot; &quot;);    // b = &quot;1 2 3 4 5 6 7&quot;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>方法Array.join()恰好与String.split()相反，后者是通过将一个字符串分隔成几个元素来创建数组</p>
</blockquote>
<h3 id="1-2-reverse-方法"><a href="#1-2-reverse-方法" class="headerlink" title="1.2 reverse()方法"></a>1.2 reverse()方法</h3><p>Array.reverse()方法将颠倒数组中元素的顺序并返回一个颠倒后的数组。<strong>它在原数组上执行这一操作，所以说并不是创建了一个新数组</strong>，而是在已存在的数组中对元素进行重排。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a  = [1,2,3,4,5,6,7];</div><div class="line">a.reverse();    // a =  [7,6,5,4,3,2,1]</div></pre></td></tr></table></figure></p>
<h3 id="1-3-sort-方法"><a href="#1-3-sort-方法" class="headerlink" title="1.3 sort()方法"></a>1.3 sort()方法</h3><p>Array.sort()是在<strong>原数组上进行排序</strong>,返回排序后的数组。如果调用方法时不传入参数，那么它将按照字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果数组中有未定义的元素，这些元素将放在数组的末尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a  = [1,12,23,14,,undefined,null,NaN,56,6,7,&quot;a&quot;,&#123;&#125;,[]];</div><div class="line">a.sort();    //[[], 1, 12, 14, 23, 56, 6, 7, &quot;NaN&quot;, &#123;&#125;, &quot;a&quot;, null,undefined,undefined × 1]  </div><div class="line">//返回的NaN已经是一个字符串，说明在比较过程中将其转化成了字符串进行比较</div></pre></td></tr></table></figure></p>
<p>仔细看可以发现，上面顺序并没有按照数字大小进行排序。如果想按照其他标准进行排序，就需要提供比较函数。该函数比较前后两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>
<ul>
<li>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，在排序后的数组中 a 应该出现在 b 之后，则返回一个大于 0 的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a  = [1,12,23,14,,undefined,null,NaN,56,6,7,&quot;a&quot;,&#123;&#125;,[]];</div><div class="line">a.sort((a,b) =&gt; &#123;return a - b&#125;);   //[null, Array(0), NaN, Object, 1, 6, 7, 12, 14, 23, 56, &quot;a&quot;,undefined, undefined × 1]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-4-concat-方法"><a href="#1-4-concat-方法" class="headerlink" title="1.4 concat()方法"></a>1.4 concat()方法</h3><p>Array.concat() 方法用于连接两个或多个参数（数组，字符串等），<strong>该方法不会改变现有的数组，而会返回连接多个参数的一个新数组</strong>。如果传入的参数是数组，那么它将被展开，将元素添加到返回的数组中。但要注意，<strong>concat并不能递归的展开一个元素为数组的参数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3];</div><div class="line">let b = a.concat(4,5,[6,7,[9,10]]);  // b = [1,2,3,4,5,6,7,[9,10]]];</div></pre></td></tr></table></figure>
<h3 id="1-5-slice-方法"><a href="#1-5-slice-方法" class="headerlink" title="1.5 slice()方法"></a>1.5 slice()方法</h3><p>Array.slice() 方法可从已有的数组中返回指定的一个片段(slice)，或者说是子数组。<strong>它是从原数组中截取了一个片段，并返回到了一个新数组</strong>。</p>
<p>Array.slice(a,b) 它有两个参数a,b</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td><strong>必选</strong>。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td>b</td>
<td><strong>可选</strong>。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5,7,8];</div><div class="line">let b = a.slice(3);     //  [4, 5, 7, 8]</div><div class="line">let c = a.slice(3,5);   //  [4, 5]</div><div class="line">let d = a.slice(-5,-2); //  [3, 4, 5]</div><div class="line">let d = a.slice(2,1);   //  []</div></pre></td></tr></table></figure>
<p>请注意，该方法并不会修改数组，而是返回一个新的子数组。如果想删除数组中的一段元素，应该使用下面这个方法 Array.splice()。</p>
<h3 id="1-6-splice-方法"><a href="#1-6-splice-方法" class="headerlink" title="1.6 splice()方法"></a>1.6 splice()方法</h3><p>Array.splice() 方法从数组中添加/删除元素，然后<strong>返回被删除的元素</strong>。<strong>它在原数组上修改数组</strong>，并不像slice和concat那样创建新数组。注意，虽然splice和slice名字非常相似，但是执行的却是完全不同的操作。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td><strong>必选,整数</strong>。规定添加/删除项目的位置，使用负数可从数组结尾处倒着寻找位置。</td>
</tr>
<tr>
<td>howmany</td>
<td><strong>可选,整数</strong>。要删除的元素数量。如果设置为 0，则不会删除元素。如果没有选择，则默认从index开始到数组结束的所有元素</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td><strong>可选</strong>。向数组添加新的元素。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5,7,8];</div><div class="line">let b = a.splice(3);     // a = [1,2,3]  b = [4, 5, 7, 8]</div><div class="line">-----------------------------------------------------------</div><div class="line">let c = [1,2,3,4,5,7,8]; </div><div class="line">let d = c.splice(3,5); // c = [1,2]   d = [3,4,5,7,8]</div><div class="line">-----------------------------------------------------------</div><div class="line">let e = [1,2,3,4,5,7,8]; </div><div class="line">let f = e.splice(3,2,111,222,[1,2]); // e = [1, 2, 3, 111, 222,[1,2], 7, 8]   f = [4,5]</div></pre></td></tr></table></figure>
<p>大家要记住<strong>slice()和splice()两个方法第二个参数代表的意义是不一样的</strong>。虽然这很基础，可是有时候还是会弄混。</p>
<h3 id="1-7-push-和pop-方法"><a href="#1-7-push-和pop-方法" class="headerlink" title="1.7 push()和pop()方法"></a>1.7 push()和pop()方法</h3><p>Array.push() 方法可向数组的末尾添加一个或多个元素，并<strong>返回新的长度</strong>。</p>
<p>Array.pop()方法用于删除并<strong>返回数组的最后一个元素</strong>。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5];</div><div class="line">let b = a.pop(); //a = [1,2,3,4]    b = 5</div><div class="line">let c =  a.push(1,3,5); // a = [1,2,3,4,1,3,5]  c = 7</div></pre></td></tr></table></figure></p>
<p>上面两个方法都是直接对原数组进行操作。通过上面两个方法可以实现一个先进后出的栈。</p>
<h3 id="1-8-unshift和shift-方法"><a href="#1-8-unshift和shift-方法" class="headerlink" title="1.8 unshift和shift()方法"></a>1.8 unshift和shift()方法</h3><p>unshift，shift()的方法行为和push()，pop()非常相似，只不过他们是对数组的头部元素进行插入和删除。</p>
<p>Array.unshift() 方法可向数组的头部添加一个或多个元素，并<strong>返回新的长度</strong>。</p>
<p>Array.shift()方法用于删除并<strong>返回数组的第一个元素</strong>。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5];</div><div class="line">let b = a.shift(); //a = [2,3,4,5]    b = 1</div><div class="line">let c =  a.unshift(1,3,5); // a = [1,3,5,2,3,45]  c = 7</div></pre></td></tr></table></figure></p>
<h3 id="1-9-toString-和toLocaleString-方法"><a href="#1-9-toString-和toLocaleString-方法" class="headerlink" title="1.9 toString()和toLocaleString()方法"></a>1.9 toString()和toLocaleString()方法</h3><p>和所有javascript的对象一样，数组也有toString()方法，这个方法可以将数组的每一个元素转化成字符串(如果必要的话，就调用元素的toString()方法)，然后输出字符串的列表，字符串之间用逗号隔开。(用我的话来理解，其实就是遍历数组元素调用每个元素自身的toString()方法，然后用逗号连接)</p>
<p>toString()的返回值和没有参数的join()方法返回的字符串相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = let e = [1,undefined,null,Boolean,&#123;&#125;,[],function()&#123;console.log(1);&#125;];</div><div class="line">let b = a.toString();   // b = &quot;1,,,function Boolean() &#123; [native code] &#125;,[object Object],,function ()&#123;console.log(1);&#125;&quot;</div></pre></td></tr></table></figure></p>
<p>注意，输出的结果中，返回的数组值周围没有括号。</p>
<p>toLocaleString方法是toString()方法的<strong>本地化版本</strong>。它是使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</p>
<p>虽然是两个方法，但是一般元素两个方法的输出结果却基本是一样的，去网上找了相关文章，发现只有两种情况比较有区分，一个是时间，一个是4位数字以上的数字,举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let a = 1111;</div><div class="line">let b = a.toLocaleString();   // b = &quot;1,111&quot;</div><div class="line">let c = a.toString();   // c = &quot;1111&quot;;</div><div class="line">-------------------------------------------------------</div><div class="line">let date = new Date();</div><div class="line">let d = date.toString();    // d = &quot;Sun Sep 03 2017 21:52:18 GMT+0800 (中国标准时间)&quot;</div><div class="line">let e = date.toLocaleString();  //e = &quot;2017/9/3 下午9:52:18&quot;</div></pre></td></tr></table></figure></p>
<p>好吧，这个api和数组关系不大。。。主要还是和数组中元素自身有关。啊哈哈，尴尬。</p>
<h3 id="1-10-valueOf"><a href="#1-10-valueOf" class="headerlink" title="1.10 valueOf()"></a>1.10 valueOf()</h3><p>Array.valueOf()方法在日常中用的比较少，该方法继承与Object。javascript中许多内置对象都针对自身重写了该方法，数组Array.valueOf()直接返回自身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1,&quot;1&quot;,&#123;&#125;,[]];</div><div class="line">let b = a.valueOf();</div><div class="line">a === b; // true</div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>好啦，关于ES3的方法就不详细描述了，我相信大家基本上都已经完全是烂熟于心的那种，唯一可能需要加强记忆的就是一些参数含义，返回数据这些了。</p>
</blockquote>
<hr>
<h2 id="2-ES5中的数组方法"><a href="#2-ES5中的数组方法" class="headerlink" title="2 ES5中的数组方法"></a>2 ES5中的数组方法</h2><ol>
<li>ES5中的数组方法在各大浏览器的兼容性</li>
</ol>
<ul>
<li>Opera 11+</li>
<li>Firefox 3.6+</li>
<li>Safari 5+</li>
<li>Chrome 8+</li>
<li>Internet Explorer 9+</li>
</ul>
<p>2.Array在ES5新增的方法中接受两个参数，第一个参数都是function类型，必选，默认有传参，这些参数分别是：</p>
<ul>
<li>currentValue : 数组当前项的值</li>
<li>index : 数组当前项的索引</li>
<li>array : 数组对象本身</li>
</ul>
<p>第二个参数是当执行回调函数时指向的this(参考对象)，不提供默认为window，严格模式下为undefined。</p>
<p>以forEach举例</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback, thisArg)</div><div class="line"></div><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, thisArg)</div></pre></td></tr></table></figure></p>
<p><strong>例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//demo,注意this指向</div><div class="line">//我这个demo没有用箭头函数来测试</div><div class="line">let a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line"></div><div class="line">a.forEach(function(currentValue, index, array)&#123;</div><div class="line">    this.info(currentValue, index, array);</div><div class="line">&#125;,&#123;info:function(value,index,array)&#123;</div><div class="line">    console.log(`当前值$&#123;value&#125;，下标$&#123;index&#125;,数组$&#123;array&#125;`)&#125;</div><div class="line">&#125;);</div><div class="line">function (value,index,array)&#123;</div><div class="line">    console.log(`外放方法 ： 当前值$&#123;value&#125;，下标$&#123;index&#125;,数组$&#123;array&#125;`)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当前值a,下标0,数组a,b,c</div><div class="line">// 当前值b,下标1,数组a,b,c</div><div class="line">// 当前值c,下标2,数组a,b,c</div></pre></td></tr></table></figure></p>
<p>3.ES5中的所有关于遍历的方法按升序为数组中含有效值的每一项执行一次callback函数，那些<strong>已删除（使用delete方法等情况）或者未初始化的项</strong>将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。</p>
<p><strong>例子：数组哪些项被跳过了</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function logArrayElements(element, index, array) &#123;</div><div class="line">    console.log(`a[$&#123;index&#125;] = $&#123;element&#125;`);</div><div class="line">&#125;</div><div class="line">let xxx;  //定义未赋值</div><div class="line">let a = [1,2,&quot;&quot;, ,undefined,xxx,3];</div><div class="line">delete a[1];  // 移除 2</div><div class="line">a.forEach(logArrayElements);</div><div class="line"></div><div class="line">// a[0] = 1</div><div class="line">// 注意索引1被跳过了，因为在数组的这个位置没有项 被删除了</div><div class="line">// a[2] = &quot;&quot;</div><div class="line">// 注意索引3被跳过了，因为在数组的这个位置没有项,可以理解成没有被初始化</div><div class="line">// a[4] = undefined</div><div class="line">// a[5] = undefined</div><div class="line">// a[6] = 3</div></pre></td></tr></table></figure></p>
<p>好了，上面3点基本上是ES5中所有方法的共性，下面就不重复述说了。开始正文解析每个方法的不同了</p>
<hr>
<h3 id="2-1-forEach"><a href="#2-1-forEach" class="headerlink" title="2.1 forEach()"></a>2.1 forEach()</h3><p>Array.forEach() 为每个数组元素执行callback函数；不像map() 或者reduce() ，<strong>它总是返回 undefined值</strong>，并且不可链式调用。典型用例是在一个链的最后执行副作用。</p>
<blockquote>
<p>注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要跳出函数，推荐使用Array.some。如果可以，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。</p>
</blockquote>
<p><strong>如果数组在迭代时被修改了</strong></p>
<p>下面的例子输出”one”, “two”, “three”。当到达包含值”two”的项时，整个数组添加了一个项在第一位，这导致所有的元素下移一个位置。此时在下次执行回调中，因为元素 “two”符合条件，结果一直增加元素，直到遍历次数完毕。forEach()不会在迭代之前创建数组的副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let a = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];</div><div class="line">let b = a.forEach((value,index,arr) =&gt; &#123;</div><div class="line">  if (value === &quot;two&quot;) &#123;</div><div class="line">    a.unshift(&quot;zero&quot;);</div><div class="line">  &#125;</div><div class="line">  return &quot;new&quot; + value</div><div class="line">&#125;);</div><div class="line">// one,0,[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div><div class="line">// two,1,[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div><div class="line">// two,2,[&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div><div class="line">// two,3,[&quot;zero&quot;,&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div></pre></td></tr></table></figure></p>
<p>看完例子可以发现，使用 forEach 方法处理数组时，数组元素的范围是在callback方法第一次调用之前就已经确定了。在 forEach 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 forEach 方法遍历到它们的那一个索引时的值。</p>
<h3 id="2-2-map"><a href="#2-2-map" class="headerlink" title="2.2 map()"></a>2.2 map()</h3><p>Array.map 方法会给原数组中的每个元素都按顺序调用一次callback函数。callback每次执行后的返回值（没有指定返回值则返回undefined）组合起来形成一个新数组。</p>
<p><strong>例子：返回每个元素的平方根的数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,4,9];</div><div class="line">let b = a.map((value) =&gt; &#123;</div><div class="line">   return Math.sqrt(value);    //如果没有return，则默认返回undefined</div><div class="line">&#125;);</div><div class="line">// b= [1,2,3]</div></pre></td></tr></table></figure></p>
<h3 id="2-3-filter"><a href="#2-3-filter" class="headerlink" title="2.3 filter()"></a>2.3 filter()</h3><p>Array.filter()为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中</p>
<p><strong>例子：数组去重</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,32,6,79,0,1,1,8];</div><div class="line">let b = a.filter((value,index,arr) =&gt; &#123;</div><div class="line">   return arr.indexOf(value) === index;</div><div class="line">&#125;);</div><div class="line">// b = [1, 2, 3, 4, 32, 6, 79, 0, 8]</div></pre></td></tr></table></figure></p>
<h3 id="2-4-some"><a href="#2-4-some" class="headerlink" title="2.4 some()"></a>2.4 some()</h3><p>Array.some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，<strong>some 将会立即返回 true。否则，some 返回 false</strong>。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p><strong>例子：查看数组内是否含有大于0的元素</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [-1,4,9];</div><div class="line">let b = a.some((value) =&gt; &#123;</div><div class="line">   return value &gt; 0;    //如果没有return，则默认返回undefined，将无法告诉some判断</div><div class="line">&#125;);</div><div class="line">// b = true</div></pre></td></tr></table></figure></p>
<blockquote>
<p>some方法可以理解成拥有跳出功能的forEach()函数，可以用在在一些需要中断函数的地方</p>
<h3 id="2-5-every"><a href="#2-5-every" class="headerlink" title="2.5 every()"></a>2.5 every()</h3></blockquote>
<p>Array.every() 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>
<p><strong>例子：检测所有数组元素的大小，是否都大于0</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [-1,4,9];</div><div class="line">let b = a.every((value) =&gt; &#123;</div><div class="line">   return value &gt; 0;    //如果没有return，则默认返回undefined</div><div class="line">&#125;);</div><div class="line">// b = false</div></pre></td></tr></table></figure></p>
<h4 id="2-6-indexOf"><a href="#2-6-indexOf" class="headerlink" title="2.6 indexOf()"></a>2.6 indexOf()</h4><p>Array.indexOf()使用严格相等（strict  equality，即===）进行判断searchElement与数组中包含的元素之间的关系。</p>
<p>Array.indexOf()提供了两个参数，第一个searchElement代表要查询的元素，第二个代表fromIndex表示从哪个下标开始查找，默认为0。</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.indexOf(searchElement)</div><div class="line">arr.indexOf(searchElement, fromIndex = 0)</div></pre></td></tr></table></figure></p>
<p>Array.indexOf()会返回首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1</p>
<p><strong>例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let array = [2, 5, 9];</div><div class="line">array.indexOf(2);     // 0</div><div class="line">array.indexOf(7);     // -1</div><div class="line">array.indexOf(9, 2);  // 2</div><div class="line">array.indexOf(2, -1); // -1</div><div class="line">array.indexOf(2, -3); // 0</div></pre></td></tr></table></figure></p>
<h3 id="2-7-lastIndexOf"><a href="#2-7-lastIndexOf" class="headerlink" title="2.7 lastIndexOf()"></a>2.7 lastIndexOf()</h3><p>Array.lastIndexOf()就不细说了，其实从名字大家也可以看出来，indexOf是正向顺序查找，lastIndexOf是反向从尾部开始查找，但是返回的<strong>索引下标仍然是正向的顺序索引</strong><br>。<br><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.lastIndexOf(searchElement, fromIndex = arr.length - 1)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，只是查找的方向相反，fromIndex和返回的索引都是正向顺序的，千万不要搞混了（感觉我这么一说，大家可能搞混了，捂脸）。</p>
</blockquote>
<p><strong>例子：各种情况下的的indexOf</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9, 2];</div><div class="line">var index = array.lastIndexOf(2);   // index = 3</div><div class="line">index = array.lastIndexOf(7);   // index = -1</div><div class="line">index = array.lastIndexOf(2, 3);    // index = 3</div><div class="line">index = array.lastIndexOf(2, 2);    // index = 0</div><div class="line">index = array.lastIndexOf(2, -2);   // index = 0</div><div class="line">index = array.lastIndexOf(2, -1);   // index = 3</div></pre></td></tr></table></figure></p>
<h3 id="2-8-reduce"><a href="#2-8-reduce" class="headerlink" title="2.8 reduce()"></a>2.8 reduce()</h3><p>Array.reduce() 为数组中的每一个元素依次执行回调函数,最后返回一个函数累计处理的结果。</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)</div></pre></td></tr></table></figure></p>
<p>reduce的回调函数中的参数与前面的不同，多了第一个参数，是上一次的返回值</p>
<ul>
<li>accumulator : 上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue : 数组当前项的值</li>
<li>currentIndex : 数据当前项的索引。第一次遍历时，如果提供了 initialValue ，从0开始；否则从1开始</li>
<li>array : 调用 reduce 的数组</li>
<li>initialValue : 可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。<strong>空数组调用reduce时没有设置初始值将会报错</strong>。</li>
</ul>
<p><strong>例子：数组求和</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let sum = [0, 1, 2, 3].reduce(function (o,n) &#123;</div><div class="line">  return o + n;</div><div class="line">&#125;);</div><div class="line">// sum = 6</div></pre></td></tr></table></figure></p>
<p>对了，当回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：</p>
<ul>
<li>调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；</li>
<li>没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。</li>
</ul>
<p><strong>例子：reduce数组去重</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[1,2,3,4,5,6,78,4,3,2,21,1].reduce(function(accumulator,currentValue)&#123;</div><div class="line">	if(accumulator.indexOf(currentValue) &gt; -1)&#123;</div><div class="line">		return accumulator;</div><div class="line">	&#125;else&#123;</div><div class="line">		accumulator.push(currentValue);</div><div class="line">        return accumulator;</div><div class="line">	&#125;</div><div class="line">&#125;,[])</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 ：如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>
</blockquote>
<h3 id="2-9-reduceRight-方法"><a href="#2-9-reduceRight-方法" class="headerlink" title="2.9 reduceRight()方法"></a>2.9 reduceRight()方法</h3><p>Array.reduceRight() 为数组中的每一个元素依次执行回调函数，方向相反，从右到左,最后返回一个函数累计处理的结果。</p>
<p>因为这个方法和reduce方法基本是一模一样的，除了方法相反，所以就不详细的再写一遍了</p>
<h3 id="2-10-isArray-方法"><a href="#2-10-isArray-方法" class="headerlink" title="2.10 isArray()方法"></a>2.10 isArray()方法</h3><p>之所以将这个方法放在最后，是因为这个方法和前面的不太一致，是用于确定传递的值是否是一个 Array,使用方法也很简单</p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Array.isArray([1,2,3]);  //true</div><div class="line">let b = Array.isArray(document.getElementsByTagName(&quot;body&quot;));  //类数组也为false</div></pre></td></tr></table></figure></p>
<p>不过感觉除非是临时判断，不然一般也不会用这个方法去判断，一般还是下面这种万金油型的吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString.call([]).slice(8, -1) === &quot;Array&quot;;//true</div></pre></td></tr></table></figure>
<hr>
<h2 id="gt-好啦，关于ES5的方法基本上就讲到这里了，感觉自己在深入去看了一些文章之后，还是有一些额外的收获的。比如对reduce这个平时不常用的方法了解更加深刻了，感觉之前很多遍历收集数据的场景其实用reduce更加方便。"><a href="#gt-好啦，关于ES5的方法基本上就讲到这里了，感觉自己在深入去看了一些文章之后，还是有一些额外的收获的。比如对reduce这个平时不常用的方法了解更加深刻了，感觉之前很多遍历收集数据的场景其实用reduce更加方便。" class="headerlink" title="&gt; 好啦，关于ES5的方法基本上就讲到这里了，感觉自己在深入去看了一些文章之后，还是有一些额外的收获的。比如对reduce这个平时不常用的方法了解更加深刻了，感觉之前很多遍历收集数据的场景其实用reduce更加方便。"></a>&gt; 好啦，关于ES5的方法基本上就讲到这里了，感觉自己在深入去看了一些文章之后，还是有一些额外的收获的。比如对reduce这个平时不常用的方法了解更加深刻了，感觉之前很多遍历收集数据的场景其实用reduce更加方便。</h2><h2 id="3-ES6中的数组方法"><a href="#3-ES6中的数组方法" class="headerlink" title="3 ES6中的数组方法"></a>3 ES6中的数组方法</h2><blockquote>
<p>不同于es5主要以遍历方法为主，es6的方法是各式各样的，不过必须要说一句，在性能上，es6的效率基本上是最低的。</p>
</blockquote>
<h3 id="3-1-…方法——concat方法的增强"><a href="#3-1-…方法——concat方法的增强" class="headerlink" title="3.1 …方法——concat方法的增强"></a>3.1 …方法——concat方法的增强</h3><p>英文名字叫做Spread syntax，中文名字叫做扩展运算符。</p>
<h3 id="3-2-from-方法"><a href="#3-2-from-方法" class="headerlink" title="3.2 from()方法"></a>3.2 from()方法</h3><h3 id="3-3-of-方法"><a href="#3-3-of-方法" class="headerlink" title="3.3 of()方法"></a>3.3 of()方法</h3><p>Array.of()方法可以将传入参数以顺序的方式返回成一个新数组的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let a = Array.of(1, 2, 3); // a = [1, 2, 3]</div></pre></td></tr></table></figure></p>
<p>其实，刚看到这个api和他的用途，还是比较懵逼的，因为看上去这个方法就是直接将传入的参数变成一个数组之外，就没有任何区别了，那么我为什么不直接用以前的写法去实现类似的效果呢，比如 let ＝ [1,2,3];而且看上去也更加直接。然后我去翻了下最新的ECMAScript草案，其中有这么一句话</p>
<blockquote>
<p>The of function is an intentionally generic factory method; it does not require that its this value be the Array constructor. Therefore it can be transferred to or inherited by other constructors that may be called with a single numeric argument.</p>
</blockquote>
<p>自己理解了一下，其实大概意思就是说为了弥补Array构造函数传入单个函数的不足，所以出了一个of这个更加通用的方法，举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = new Array(1);//a = [undefined × 1]</div><div class="line">let b = new Array(1,2);// b = [1,2]</div></pre></td></tr></table></figure></p>
<p>大家可以注意到传入一个参数和传入两个参数的结果，完全是不一样的，这就很尴尬了。而为了避免这种尴尬，es6则出了一种通用的of方法，不管你传入了几个参数，都是一种相同类型的输出结果。</p>
<p>不过我好奇的是，如果只传入几个参数，为什么不直接let a = [1,2,3];效率和直观性也更加的高。如果要创建一个长度的数组，我肯定还是选let a = new Array(10000),这种形式，实在没有感觉到Array.of的实用场景，希望大家可以给我点指导。</p>
<h3 id="3-4-copyWithin-方法"><a href="#3-4-copyWithin-方法" class="headerlink" title="3.4 copyWithin()方法"></a>3.4 copyWithin()方法</h3><h3 id="3-5-find-和-findIndex-方法"><a href="#3-5-find-和-findIndex-方法" class="headerlink" title="3.5 find() 和 findIndex()方法"></a>3.5 find() 和 findIndex()方法</h3><p> Array.find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br> Array.findIndex() 方法返回数组中满足提供的测试函数的第一个元素的值的索引。否则返回 -1。</p>
<p> 这两个方法其实使用非常相似，使用场景有点像ES5中Array.some，都是在找到第一个满足条件的时候，跳出循环，区别的是，三种返回的值完全不一样，我想这也许是为什么要在ES6中增加这两个API的原因吧，可以理解成是数组的方法的补足。</p>
<p>  <strong>例子</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> let a = [1,2,3,4,5].find((item)=&gt;&#123;return item &gt; 3&#125;);   // a = 4</div><div class="line">let b = [1,2,3,4,5].findIndex((item)=&gt;&#123;return item &gt; 3&#125;);  // b = 3</div><div class="line">let c = [1,2,3,4,5].some((item)=&gt;&#123;return item &gt; 3&#125;);    // c = true</div><div class="line"></div><div class="line">-----------------不满足条件--------------------</div><div class="line"> let a = [1,2,3,4,5].find((item)=&gt;&#123;return item &gt; 6&#125;);   // a = undefined</div><div class="line">let b = [1,2,3,4,5].findIndex((item)=&gt;&#123;return item &gt; 6&#125;);  // b = -1</div><div class="line">let c = [1,2,3,4,5].some((item)=&gt;&#123;return item &gt; 6&#125;);    // c = false</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：find()和findIndex()方法识别NaN,可以说是indexOf方法的增强（indexOf内部采用的是 === 判断）</p>
<h3 id="3-6-entries-，keys-和values-方法"><a href="#3-6-entries-，keys-和values-方法" class="headerlink" title="3.6 entries()，keys()和values() 方法"></a>3.6 entries()，keys()和values() 方法</h3></blockquote>
<h2 id="4-ES7中的数组方法"><a href="#4-ES7中的数组方法" class="headerlink" title="4 ES7中的数组方法"></a>4 ES7中的数组方法</h2><h3 id="4-1-includes-方法"><a href="#4-1-includes-方法" class="headerlink" title="4.1 includes()方法"></a>4.1 includes()方法</h3><p>方法还真是tmd多啊，，慢慢补充吧</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/js中数组所有的原生方法列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/js中数组所有的原生方法列表/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T18:16:52+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/09/03/js中数组所有的原生方法列表/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  424
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>数组应该是我们在写程序中应用到最多的数据结构了，相比于无序的对象，可控制的数组帮我们在处理数据时，实在是提供了太多的忙了。今天刚好看到一篇Array.include的文章，忽然发现经过几个ES3,ES5,ES6,ES7几个版本的更迭，数组真的有好多方法为我们提供了遍历，所以准备全部列出来，也是给自己打个标记</p>
</blockquote>
<h2 id="1-ES3中的数组方法"><a href="#1-ES3中的数组方法" class="headerlink" title="1 ES3中的数组方法"></a>1 ES3中的数组方法</h2><blockquote>
<p>ES3的兼容性使用鱼现在所有的浏览器</p>
</blockquote>
<p>记忆中es5好像是2009年出的，找到了一本2007年出版的《Javaascript权威指南》第五版</p>
<h4 id="1-1-join-方法"><a href="#1-1-join-方法" class="headerlink" title="1.1 join()方法"></a>1.1 join()方法</h4><p>Array.join()方法是将一个数组里面的所有元素转换成字符串，然后再将他们连接起来</p>
<h4 id="1-2-reverse-方法"><a href="#1-2-reverse-方法" class="headerlink" title="1.2 reverse()方法"></a>1.2 reverse()方法</h4><h4 id="1-3-sort-方法"><a href="#1-3-sort-方法" class="headerlink" title="1.3 sort()方法"></a>1.3 sort()方法</h4><h4 id="1-4-concat-方法"><a href="#1-4-concat-方法" class="headerlink" title="1.4 concat()方法"></a>1.4 concat()方法</h4><h4 id="1-5-slice-方法"><a href="#1-5-slice-方法" class="headerlink" title="1.5 slice()方法"></a>1.5 slice()方法</h4><h4 id="1-6-splice-方法"><a href="#1-6-splice-方法" class="headerlink" title="1.6 splice()方法"></a>1.6 splice()方法</h4><h4 id="1-7-push-和pop-方法"><a href="#1-7-push-和pop-方法" class="headerlink" title="1.7 push()和pop()方法"></a>1.7 push()和pop()方法</h4><h4 id="1-8-unshift和shift-方法"><a href="#1-8-unshift和shift-方法" class="headerlink" title="1.8 unshift和shift()方法"></a>1.8 unshift和shift()方法</h4><h4 id="1-8-toString-和toLocalString-方法"><a href="#1-8-toString-和toLocalString-方法" class="headerlink" title="1.8 toString()和toLocalString()方法"></a>1.8 toString()和toLocalString()方法</h4><h2 id="2-ES5中的数组方法"><a href="#2-ES5中的数组方法" class="headerlink" title="2 ES5中的数组方法"></a>2 ES5中的数组方法</h2><h4 id="2-1-forEach"><a href="#2-1-forEach" class="headerlink" title="2.1 forEach()"></a>2.1 forEach()</h4><h4 id="2-2-map"><a href="#2-2-map" class="headerlink" title="2.2 map()"></a>2.2 map()</h4><h4 id="2-3-filter"><a href="#2-3-filter" class="headerlink" title="2.3 filter()"></a>2.3 filter()</h4><h4 id="2-4-some"><a href="#2-4-some" class="headerlink" title="2.4 some()"></a>2.4 some()</h4><h4 id="2-5-every"><a href="#2-5-every" class="headerlink" title="2.5 every()"></a>2.5 every()</h4><h4 id="2-6-indexOf"><a href="#2-6-indexOf" class="headerlink" title="2.6 indexOf()"></a>2.6 indexOf()</h4><h4 id="2-7-lastIndexOf"><a href="#2-7-lastIndexOf" class="headerlink" title="2.7 lastIndexOf()"></a>2.7 lastIndexOf()</h4><h4 id="2-8-reduce"><a href="#2-8-reduce" class="headerlink" title="2.8 reduce()"></a>2.8 reduce()</h4><h4 id="2-9-reduceRight-方法"><a href="#2-9-reduceRight-方法" class="headerlink" title="2.9 reduceRight()方法"></a>2.9 reduceRight()方法</h4><h2 id="3-ES6中的数组方法"><a href="#3-ES6中的数组方法" class="headerlink" title="3 ES6中的数组方法"></a>3 ES6中的数组方法</h2><blockquote>
<p>ES6中的一部分数组方法给我的感觉更像是以前方法的简化版，也就是常说的语法糖（个人感觉）</p>
</blockquote>
<h4 id="3-1-…方法——concat方法的增强"><a href="#3-1-…方法——concat方法的增强" class="headerlink" title="3.1 …方法——concat方法的增强"></a>3.1 …方法——concat方法的增强</h4><h4 id="3-2-from-方法"><a href="#3-2-from-方法" class="headerlink" title="3.2 from()方法"></a>3.2 from()方法</h4><h4 id="3-3-of-方法"><a href="#3-3-of-方法" class="headerlink" title="3.3 of()方法"></a>3.3 of()方法</h4><h4 id="3-4-copyWithin-方法"><a href="#3-4-copyWithin-方法" class="headerlink" title="3.4 copyWithin()方法"></a>3.4 copyWithin()方法</h4><h4 id="3-4-find-和-findIndex-方法"><a href="#3-4-find-和-findIndex-方法" class="headerlink" title="3.4 find() 和 findIndex()方法"></a>3.4 find() 和 findIndex()方法</h4><p>用于初始化话数组十分方便的方法</p>
<h4 id="3-6-entries-，keys-和values-方法"><a href="#3-6-entries-，keys-和values-方法" class="headerlink" title="3.6 entries()，keys()和values() 方法"></a>3.6 entries()，keys()和values() 方法</h4><h2 id="4-ES7中的数组方法"><a href="#4-ES7中的数组方法" class="headerlink" title="4 ES7中的数组方法"></a>4 ES7中的数组方法</h2><h4 id="4-1-includes-方法"><a href="#4-1-includes-方法" class="headerlink" title="4.1 includes()方法"></a>4.1 includes()方法</h4><p>方法还真是tmd多啊，，慢慢补充吧</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/理解jquery的深拷贝源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/理解jquery的深拷贝源码/" itemprop="url">理解jquery的深拷贝</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T23:47:44+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/24/理解jquery的深拷贝源码/" class="leancloud_visitors" data-flag-title="理解jquery的深拷贝">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,855
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>好像自从使用框架之后，对jquery的依赖越来越低了，其好像已经慢慢作为一个工具库的存在了。新项目商量之下，为了减小文件大小，干脆直接不用jquer2，对于一些需要的工具函数直接从jquery提取到一个自己写的工具文件tool.js中。在提取的过程中，也慢慢理解了jquery一些工具函数的源码</p>
</blockquote>
<p>深拷贝和浅拷贝的使用场景不同，并没有好坏之分，像对一些基本数据类型，直接可以使用浅拷贝对处理数据。但是对于基本引用类型如嵌套对象，数组（包含着对象的数组），那么就需要使用到深拷贝了。</p>
<blockquote>
<p>不想看前面深浅拷贝对比的，可以直接拉到第二章看jquery源码实现</p>
</blockquote>
<hr>
<h4 id="1-浅拷贝解析"><a href="#1-浅拷贝解析" class="headerlink" title="1.浅拷贝解析"></a>1.浅拷贝解析</h4><p>原生js也有一些提供拷贝的函数，比如数组的Array.slice(0),Array.concat()，对象的Object.create(),Object.assign()等等，但是都是浅拷贝，遇到二维数组，嵌套对象就通通失败了（以前不懂的时候，真的被坑的不要不要的啊）。</p>
<p>比如下面这个例子，都是在只有基本数据类型的情况下，使用浅拷贝就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,34,5,67,8,9];</div><div class="line">let cloneArr = arr.slice(4);</div><div class="line">console.log(cloneArr);  //  [67, 8, 9]</div><div class="line"></div><div class="line">cloneArr[0] = 100;  //  修改cloneArr</div><div class="line">console.log(arr);   //  [1,2,34,5,67,8,9],修改cloneArr不影响原数组arr</div><div class="line"></div><div class="line">----------------</div><div class="line"></div><div class="line">let obj = &#123;a : 1,b : 2,c : 3,&#125;;</div><div class="line">let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象</div><div class="line">console.log(cloneObj); //   cloneObj = &#123;a : 1,b : 2,c : 3,&#125;;</div><div class="line"></div><div class="line">cloneObj.a = 444;   //修改对象</div><div class="line">console.log(obj);   //  obj = &#123;a : 1,b : 2,c : 3,&#125;; 修改拷贝对象不影响源对象</div></pre></td></tr></table></figure></p>
<p>但是如果以上例子将基本数据类型换成引用类型Object和Array呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,&#123;a : 3&#125;,&#123;b : 4&#125;,5];</div><div class="line">let cloneArr = arr.slice(2);</div><div class="line">console.log(cloneArr);  //  [&#123;a : 3&#125;,&#123;b : 4&#125;,5];</div><div class="line"></div><div class="line">cloneArr[0].a = 100;  //  修改cloneArr</div><div class="line">console.log(arr);   //  [1,2,&#123;a : 100&#125;,&#123;b : 4&#125;,5],修改cloneArr影响原数组arr</div><div class="line"></div><div class="line">----------------</div><div class="line"></div><div class="line">let obj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;</div><div class="line">let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象</div><div class="line">console.log(cloneObj); //   cloneObj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;</div><div class="line"></div><div class="line">cloneObj.a.aa = 100;   //修改对象</div><div class="line">console.log(obj);   //  obj = &#123;a : &#123;aa : 100&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;; 修改拷贝对象影响到了源对象</div></pre></td></tr></table></figure>
<p>为什么会这样子，原因其实也不复杂。js内存分为栈内存和堆内存。所有的基本数据类型都是存储在栈内存中，而引用类型则是存储在堆内存中，提供了一个地址放在了栈内存中。当我们要获取引用类型的值时，先从栈内存获得地址，再根据地址去堆内存中获得值。因此也叫按引用访问。</p>
<blockquote>
<p>(去网上浅拷贝了一张图片，因为拷贝了一个图片地址)<br><img src="http://img.blog.csdn.net/20141212220233511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGRkMTk5MTA1MDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="去网上浅拷贝了一张图片，拷贝了一个图片地址"></p>
</blockquote>
<p>而我们上面例子中，每个数组和对象每个属性存储的引用类型obj其实是个地址，我们只是简单的拷贝了属性值，其实就是拷贝了一个地址。所以我们在新对象里进行修改时，由于是通过同一个地址修改了值。因为和原对象共用了一个地址，所以自然就修改了原对象的值了。</p>
<h4 id="2-深拷贝解析"><a href="#2-深拷贝解析" class="headerlink" title="2.深拷贝解析"></a>2.深拷贝解析</h4><p>前面解析了浅拷贝。因为我们项目对大型数据处理占据了大头，其中不可避免的会经常用到深拷贝这块。那么深拷贝是怎么实现的。</p>
<p>其实也很简单，就是根据地址找到你堆内存中的值，不断递归深入拷贝下去，直到为基本数据类型为止，接下去就贴上深拷贝代码。</p>
<p>在讲jquey前，还有一个很暴力的方式<strong>JSON.parse()和JSON.stringify()</strong>;缺点是</p>
<ul>
<li>数据不能包含函数。</li>
<li>如果某个对象属性值为null，会形成一个对象的闭环<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: 2,</div><div class="line">	c: [1,2,3],</div><div class="line">    d: function() &#123; </div><div class="line">        console.log(&quot;asdfghj&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let result1 = JSON.stringify(target);</div><div class="line">console.log(result1); //    输出结果为&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[1,2,3]&#125;&quot;，函数直接没了</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">  foo: &#123;</div><div class="line">    name: &apos;foo&apos;,</div><div class="line">    bar: &#123;</div><div class="line">      name: &apos;bar&apos;</div><div class="line">      baz: &#123;</div><div class="line">        name: &apos;baz&apos;,</div><div class="line">        aChild: null // 待会将指向obj.bar</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo形成环</div><div class="line">JSON.stringify(obj) // =&gt; TypeError: Converting circular personucture to JSON</div></pre></td></tr></table></figure>
</li>
</ul>
<p>好了，最后贴上jquery深拷贝的代码和自己一些理解的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">$.fn.extend = function () &#123;</div><div class="line">    //jquery喜欢在初始定义好所有的变量</div><div class="line">    let options,//  被拷贝的对象</div><div class="line">    	name,// 遍历时的属性</div><div class="line">    	src,// 返回对象本身的属性值</div><div class="line">    	copy,// 需要拷贝的内容</div><div class="line">    	copyIsArray,//  判断是否为数组</div><div class="line">    	clone,// 返回拷贝的内容</div><div class="line">    	target = arguments[0] || &#123;&#125;,</div><div class="line">    	i = 1,</div><div class="line">    	length = arguments.length,</div><div class="line">    	deep = false;// 默认为浅拷贝</div><div class="line">    	</div><div class="line">    //target 是传入的第一个参数,表示是否要深递归</div><div class="line">    if(typeof target === &apos;boolean&apos;)&#123;</div><div class="line">    	deep = target;</div><div class="line">    	//既然为boolean，则此处初始化target为第二个参数或者空对象</div><div class="line">    	target = arguments[i] || &#123;&#125;;</div><div class="line">    	// 如果传了类型为 boolean 的第一个参数，i 则从 2 开始</div><div class="line">    	i ++</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //如果传入的第一个参数不是对象或者其他，初始化为一个空对象</div><div class="line">    if(typeof target !== &apos;object&apos; &amp;&amp; $.isFunction(target))&#123;</div><div class="line">    	target = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">    //如果只传入了一个参数，表示是jquery静态方法，直接返回自身</div><div class="line">    if(i === length)&#123;</div><div class="line">    	target = this;</div><div class="line">    	i --;</div><div class="line">    &#125;</div><div class="line">    for(; i &lt; length; i ++)&#123;</div><div class="line">    	if((options = arguments[i]) !== null )&#123;</div><div class="line">            for( name in options)&#123;</div><div class="line">            	src = target[name];//获得源对象的值</div><div class="line">            	copy = options[name];//获得要拷贝对象的值</div><div class="line">            	//说是为了避免无限循环，例如 extend(true, target, &#123;&apos;target&apos;:target&#125;);</div><div class="line">            	if(target === copy) continue;</div><div class="line">            	//如果是数据正确，且是一个纯粹的对象（纯粹的对象指的是 通过 &quot;&#123;&#125;&quot; 或者 &quot;new Object&quot; 创建的）或者是一个数组的话</div><div class="line">            	if(deep &amp;&amp; copy &amp;&amp; ($.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))&#123;</div><div class="line">                    //如果是一个数组的话</div><div class="line">                    if(copyIsArray)&#123;</div><div class="line">                        copyIsArray = false;</div><div class="line">                        clone = src &amp;&amp; Array.isArray(src) ? src : [];//判断源对象是不是数组，如果不是，直接变为空数组，拷贝属性高优先原则</div><div class="line">                    &#125; else &#123;</div><div class="line">                        clone = src &amp;&amp; $.isPlainObject(src) ? src : &#123;&#125;;//判断原对象属性是否有值，如果有的话，直接返回原值，否则新建一个空对象</div><div class="line">                    &#125;</div><div class="line">                    //继续深拷贝下去</div><div class="line">                    target[name] = $.extend(deep,clone,copy);</div><div class="line">            	&#125;else if(copy !== undefined)&#123;</div><div class="line">                    //如果不为空，则不是需要深拷贝的数据和对象，而是string,data,boolean等等，可以直接赋值</div><div class="line">                    target[name] = copy;</div><div class="line">            	&#125;</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    // 返回新的拷贝完的对象</div><div class="line">    return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在看上段代码中，又发现了几个好方法在业务中会用到的，可以让代码更严谨<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//判断数据类型</div><div class="line">//判断是否为纯正的数据对象</div><div class="line">isPlainObject: function( obj ) &#123;</div><div class="line">    //如果数据不正确，不是对象类型，或者是dom对象，window对象，则直接返回false</div><div class="line">    if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) &#123;</div><div class="line">    	return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //这段代码是为了兼容IE89存在的，查看是否有constructor属性，如果没有必然是数据对象</div><div class="line">    try &#123;</div><div class="line">    	if ( obj.constructor &amp;&amp;</div><div class="line">            !core_hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp;</div><div class="line">            !core_hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) &#123;</div><div class="line">            return false;</div><div class="line">    	&#125;</div><div class="line">    &#125; catch ( e ) &#123;</div><div class="line">    	return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //对象中key的顺序会将自身属性排在最前面遍历，如果最后一个还是自身属性，则必然所有属性都是自己的  </div><div class="line">    var key;</div><div class="line">    for ( key in obj ) &#123;&#125;</div><div class="line">    </div><div class="line">    return key === undefined || core_hasOwn.call( obj, key );</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>以上基本就是jquery.extend代码的解析了。extend是jquery中一个极其重要的方法，jquery本身就用它扩展了许多静态方法和实例方法</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/promise源码解析（译）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/promise源码解析（译）/" itemprop="url">promise源码解析（译）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T23:47:44+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/20/promise源码解析（译）/" class="leancloud_visitors" data-flag-title="promise源码解析（译）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  4,582
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最新项目中有用promise几个api，对代码结构看起来的确很爽。然后想着去网上找了几篇promise库源码解析的文章。但是看了几篇，感觉还是不能够很理解，然后看到一篇翻译文章有说道q.js库的作者有对promise实现的递进讲解，看了一下，还不错，</p>
</blockquote>
<p>Q.js作者源码分析：<a href="https://github.com/kriskowal/q/tree/v1/design" target="_blank" rel="external">Q.js作者promise递进讲解实现</a></p>
<p><a href="http://div.io/topic/1351" target="_blank" rel="external">网上找的promise源码翻译</a>。文章有些地方翻译的很好，但是对比原文发现少了一些内容，所以读起来很不顺畅。所以自己根据原文也翻译了一遍。对了，本文适合用过promise的人阅读。如果你还没有接触过。可以右转<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰的promise讲解</a></p>
<hr>
<h4 id="一、极简版异步回调"><a href="#一、极简版异步回调" class="headerlink" title="一、极简版异步回调"></a>一、极简版异步回调</h4><p>假如你正在写一个函数不立即返回值函数，需要等待几秒钟后才返回执行结果，你会怎么写呢？思考几秒钟。</p>
<p>最简单的做法自然是写一个回调函数依靠定时器来返回值，比如下面这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var oneOneSecondLater = function (callback) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        callback(1);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是一个很简单解决问题的方法，但是还有改进的地方，比如能够添加代码执行错误时给出提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var maybeOneOneSecondLater = function (callback, errback) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        //进行判断情况，是执行成功的回调，还是执行错误的回调</div><div class="line">        if (Math.random() &lt; .5) &#123;</div><div class="line">            callback(1);</div><div class="line">        &#125; else &#123;</div><div class="line">            errback(new Error(&quot;Can&apos;t provide one.&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一般的做法是提供一个能同时返回值并且能抛出错误的工具。上面这个例子则演示同时提供回调和错误处理。但是这种写法实在是太定制化了，并不好。</p>
<h4 id="二、Promise基本雏形设计"><a href="#二、Promise基本雏形设计" class="headerlink" title="二、Promise基本雏形设计"></a>二、Promise基本雏形设计</h4><p>所以考虑到大多数的情况，代替最简单的返回值和抛出异常，我们更希望函数通常会返回一个对象用来表示最后执行成功或者失败的结果，而这个返回的对象就是<strong>promise</strong>。从名字上理解，promise表示承诺，那么最终这个<strong>promise</strong>（承诺）是要被<strong>resolve</strong>（履行，执行）掉的。</p>
<p>接下去我们开始迭代设计promise。我们先设计一个具有“then”方法的promise模型，通过“then”方法，我们能注册回调函数并且延迟执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var maybeOneOneSecondLater = function () &#123;</div><div class="line">    var callback;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        callback(1);</div><div class="line">    &#125;, 1000);</div><div class="line">    return &#123;</div><div class="line">        then: function (_callback) &#123;</div><div class="line">            callback = _callback;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">maybeOneOneSecondLater().then(callback1);</div></pre></td></tr></table></figure>
<p>代码写好了。但是大家仔细观察发现该方案仍然还有两个缺点</p>
<ul>
<li>一是现在方案只能执行一个添加的回调函数。最好的做法是每一个通过then添加进来的回调都能被通知到然后顺序执行。</li>
<li>二是如果这个回调函数是在promise创建好1s之后通过then添加进去，它将无法被调用。</li>
</ul>
<blockquote>
<p><strong>敲黑板，注意注意，接下去开始慢慢搭建promise了。</strong></p>
</blockquote>
<p>正常情况下，我们希望可以接收任何数量的回调，且不管是否超时，仍然可以继续注册回调。为了实现这些，我们将创建一个包含两个功能的<strong>promise对象</strong>。</p>
<p>我们暂时设计了一个defer对象，他的返回值一个包含两部分的对象（这个对象就是<strong>promise</strong>），一个用来注册观察者（就是”then方法添加回调），一个用来通知所有的观察者执行代码（就是resolve去执行之前添加的所有回调）。</p>
<p>当<strong>promise</strong>没有被<strong>resolve</strong>之前，所有回调函数会存储在一个”pengding”的数组中。</p>
<p>当<strong>promise</strong>被<strong>resolve</strong>之后，立即执行之前存储的所有回调函数，当回调函数全部执行完毕之后，我们将根据”pengding”来区分状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value;</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            value = _value</div><div class="line">            for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                pending[i](value)</div><div class="line">            &#125;</div><div class="line">            pending = undefined;</div><div class="line">        &#125;,</div><div class="line">        then(_callback)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                pending.push(_callback)</div><div class="line">            &#125;else&#123;</div><div class="line">                _callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let oneOneSecondLater = () =&gt; &#123;</div><div class="line">    let result = defer();</div><div class="line">    setTimeout(()=&gt; &#123;</div><div class="line">        result.resolve(1);</div><div class="line">    &#125;, 1000);</div><div class="line">    return result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">oneOneSecondLater().then(callback);</div></pre></td></tr></table></figure>
<p>这开始的第一步很关键啊，因为此时我们已经可以做到</p>
<ol>
<li>可以任意时间添加任意多的回调;</li>
<li>可以人为决定什么时候resolve;</li>
<li>当promise被resolve之后，还可以添加回调，只不过此时立即就执行了</li>
</ol>
<p>但是还有一些问题，比如</p>
<ol>
<li>defer可以被resolve执行多次,我们并没有给出一个错误的提示。而且事实上为了避免恶意或者无意的不断去resolve，我们仅允许第一次调用可以通知回调并执行。</li>
<li>添加回调只能通过defer.then添加，不能链式调用,即defer.then(callback).then(callback)</li>
</ol>
<p>那么接下来我们先修正第一个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                value = _value</div><div class="line">                for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                    pending[i](value)</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;else&#123;</div><div class="line">                throw new Error(&quot;A promise can only be resolved once.&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        then(_callback)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                pending.push(_callback)</div><div class="line">            &#125;else&#123;</div><div class="line">                _callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，现在我们已经保证不能重复defer.resolve()的问题了，那么我们还希望可以实现通过链式调用来添加回调。可是目前要只能通过defer().then(callback1),defer().then(callback2),defer().then(callback3)这种方式添加回调，这显然不是我们想要的方式。接下来我们将一步一步实现。</p>
<h4 id="三、promise职责分离"><a href="#三、promise职责分离" class="headerlink" title="三、promise职责分离"></a>三、promise职责分离</h4><p>但是在实现链式回调之前，为了后期结构，我们希望对我们的promise进行职责区分，一个注册观察者，一个执行观察者。根据最少授权原则，我们希望如果授权给某人一个promise，这里只允许他增加观察者；如果授权给某人resolver，他应当仅仅能决定什么时候给出解决方案。因为大量实验表明任何任何不可避免的越权行为会导致后续的改动变得很难维护。（其实就是希望把添加回调的then功能移植到promise中，从defer.then转变成defer.promise.then，保证功能的纯粹性）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value;</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                value = _value</div><div class="line">                for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                    pending[i](value)</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;else&#123;</div><div class="line">                throw new Error(&quot;A promise can only be resolved once.&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then (callback) &#123;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push(callback);</div><div class="line">                &#125; else &#123;</div><div class="line">                    callback(value);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当职责分离完之后，我们就可以接下去实现一步关键的改造</p>
<h4 id="四、promise的链式调用"><a href="#四、promise的链式调用" class="headerlink" title="四、promise的链式调用"></a>四、promise的链式调用</h4><p>上文说道要实现链式回调，我们首先要能在下一个回调函数里接受上一个回调的值。依靠上一步的职责分离的基础，我们接下来要跨非常大的一步，就是使用旧的promise去驱动新的promise。我们希望通过promise组合的使用，来实现值的传递。</p>
<p>举个例子，让你写一个相加的函数，接受两个回调函数返回的数字相加。大家可以考虑如何实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var twoOneSecondLater = function (callback) &#123;</div><div class="line">    var a, b;</div><div class="line">    var consider = function () &#123;</div><div class="line">        if (a === undefined || b === undefined)return;</div><div class="line">        callback(a + b);</div><div class="line">    &#125;;</div><div class="line">    oneOneSecondLater(function (_a) &#123;</div><div class="line">        a = _a;</div><div class="line">        consider();</div><div class="line">    &#125;);</div><div class="line">    oneOneSecondLater(function (_b) &#123;</div><div class="line">        b = _b;</div><div class="line">        consider();</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">twoOneSecondLater(function (c) &#123;</div><div class="line">    // c === 2</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面这个方法虽然做到了，但是这个方法是脆弱的，因为我们在执行相加函数时，需要额外的代码去判断相加的数字是否有效。</p>
<p>于是我们希望用更少的代码去实现上面的需求，比如就像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//上面的函数如果用更少的步骤来表达就是</div><div class="line">var a = oneOneSecondLater();</div><div class="line">var b = oneOneSecondLater();</div><div class="line">var c = a.then(function (a) &#123;</div><div class="line">    return b.then(function (b) &#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>上面这个例子其实想表达的就是实现callback返回值的传递，如callback1的返回值传给callback2，将callback2的返回值传给callback3。<br>为了实现上面例子的这种效果，我们要实现以下几点</p>
<ul>
<li>每个then方法后必须要返回一个promise</li>
<li>每一个promise被resolve后，返回的必然是一个新的promise或者是一个执行过的值</li>
<li>返回的promise最终可以带着回调的值被resolve掉（这句话有点难翻译，感觉就是promise.resolve(_value)）;</li>
</ul>
</blockquote>
<p>我们实现一个函数可以将获得的值传给下一个回调使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            callback(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过考虑到有时候返回的值不仅仅是一个值，而且还可能是一个promise函数，所以我们需要加个判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            callback(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样子我们在使用中就不需要考虑传入的值是一个普通值还是一个promise了。</p>
<p>接下来，为了能使then方法也能返回一个promise，我们来改造下then方法；我们强制将callback的返回值传入下一个promise并立即返回。<br>这个例子存储了回调的值，并在下一个回调中执行了。但是上面第三点没有实现，因为返回值可能是一个promise，那么我们继续改进一下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这一步增强之后，基本上就可以做到获得上一个回调值并不断链式调用下去了。</p>
<p>接下去我们考虑到一种比较复杂的情况，就是defer中存储的回调会在未来某个时间调用。于是我们需要在defer里面将回调进行一次封装，我们将回调中执行完后通过then方法去驱动下一个promise并传递一个返回值。</p>
<p>此外，<strong>resolve</strong>方法应该能处理本身是一个promise的情况，resolve可以将值传递给promise。因为不管是ref还是defer都可以返回一个then方法。如果promise是ref类型的，将会通过then(callback)立即执行回调。如果是promise是defer类型的，callback暂时被存储起来，依靠下一个then(callback)调用才能执行；所以变成了callback可以监听一个新的promise以便能获取完全执行后的value。</p>
<p>根据以上要求，得出了下面最终版的promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">let isPromise = (value) =&gt; &#123;</div><div class="line">    return value &amp;&amp; typeof value.then === &quot;function&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if (value &amp;&amp; typeof value.then === &quot;function&quot;)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then (callback) &#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value); // values wrapped in a promise</div><div class="line">                for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    let callback = pending[i];</div><div class="line">                    value.then(callback); // then called instead</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback) &#123;</div><div class="line">                let result = defer();</div><div class="line">                // callback is wrapped so that its return</div><div class="line">                // value is captured and used to resolve the promise</div><div class="line">                // that &quot;then&quot; returns</div><div class="line">                let callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push(callback);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let a = defer();</div><div class="line">a.promise.then(function(value)&#123;console.log(value);return 2&#125;).then(function(value)&#123;console.log(value)&#125;);</div><div class="line">a.resolve(1);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>将defer分为两个部分，一个是promise，一个是resolve</p>
</blockquote>
<p>到了这一步基本上的promise功能已经实现了，可以链式调用，可以在自己控制在未来某个时间resolve。接下去就是功能的增强和补足了。</p>
<p>这一块回调基本上就写完了，看了很久原文的描述，对着代码理解作者想表达的意思。不过英语不太好，写的磕磕绊绊。╮(╯▽╰)╭，感觉还是有些地方写的不对。希望有人能够纠错出来。</p>
<h4 id="五、提供错误的回调"><a href="#五、提供错误的回调" class="headerlink" title="五、提供错误的回调"></a>五、提供错误的回调</h4><p>为了实现错误消息的传递，我们还需要一个错误的回调函数(errback)。就像promise完全执行时调用callback一样，它会告知执行errback以及告诉我们拒绝的原因。</p>
<p>实现一个类似于前面ref的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let reject = (reason) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then(callback,errback)&#123;</div><div class="line">            return ref(errback(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最简单的实现方法是当监听到返回值时，立即执行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reject(&quot;Meh.&quot;).then((value) =&gt; &#123;&#125;,(reason) =&gt; &#123;</div><div class="line">    throw new Error(reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么接下来我们改进原来promsie这个API，引入“errback”。</p>
<p>为了将错误回调添加到代码中，defer需要添加一种新的容器来添加成功回调和错误回调。因此之前那个存储在数组(pending)中的只有一种待处理回调函数，我们需要重新设计一个同时包含成功回调和错误回调的数组([callback,errback]),根据then传入的参数决定调用哪个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">var defer = function () &#123;</div><div class="line">    var pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value);</div><div class="line">                for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    // apply the pending arguments to &quot;then&quot;</div><div class="line">                    value.then.apply(value, pending[i]);</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback, _errback) &#123;</div><div class="line">                var result = defer();</div><div class="line">                var callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                var errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback, errback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if (value &amp;&amp; typeof value.then === &quot;function&quot;)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback) &#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let reject = (reason) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback, errback) &#123;</div><div class="line">            return ref(errback(reason));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>代码写完了，但是仍然还有地方可以改进。</p>
<p>比如作者说到这一步有一个问题，就是如果按照上面这么写，那么所有的then函数就必须提供错误回调函数(_errback)，如果不提供就会出错。所以最简单的解决方法是提供一个默认的回调函数。甚至文中还说，如果仅仅是对错误回调有需要，那么忽略不写成功回调(_callback)也是可以的。所以为了满足需求，我们为_callback和_errback都提供一个默认的回调函数。（好吧，其实我就是觉得这是一个好的库的容错处理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var defer = function () &#123;</div><div class="line">    ...</div><div class="line">    return&#123;</div><div class="line">        ...</div><div class="line">        promise : &#123;</div><div class="line">             then: function (_callback, _errback) &#123;</div><div class="line">                var result = defer();</div><div class="line">                // 提供一个默认的成功回调和错误回调</div><div class="line">                _callback = _callback || function (value) &#123;</div><div class="line">                    // 默认执行</div><div class="line">                    return value;</div><div class="line">                &#125;;</div><div class="line">                _errback = _errback || function (reason) &#123;</div><div class="line">                    // 默认拒绝</div><div class="line">                    return reject(reason);</div><div class="line">                &#125;;</div><div class="line">                var callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                var errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback, errback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，现在我们已经实现了接收构造或者隐含的错误回调<a href="https://github.com/kriskowal/q/blob/v1/design/q6.js" target="_blank" rel="external">这一步的完成版</a></p>
<h4 id="六、安全性和稳定性"><a href="#六、安全性和稳定性" class="headerlink" title="六、安全性和稳定性"></a>六、安全性和稳定性</h4><p>我们还有需要需要提高的地方就是要保证callbacks和errbacks在未来他们被调用的时候，应该是和注册时的顺序是保持一致的。这将显著降低异步编程中流程控制出错可能性。文中举了一个有趣的小例子.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var blah = function () &#123;</div><div class="line">    var result = foob().then(function () &#123;</div><div class="line">        return barf();</div><div class="line">    &#125;);</div><div class="line">    var barf = function () &#123;</div><div class="line">        return 10;</div><div class="line">    &#125;;</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面这个函数在执行后会出现两种情况，一是抛出一个异常，二是顺利执行并返回了值10。而决定是哪个结果的是foob()是否在正确顺序里。因为我们希望哪怕回调在未来被延迟执行了，它能够执行成功。</p>
<p>下面添加了一个enqueue方法，我的理解就是依靠setTimeout的异步将所有回调按照顺序添加到任务队列中，保证按照顺序执行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">let enqueue = (callback) =&gt; &#123;</div><div class="line">    setTimeout(callback,1)</div><div class="line">&#125;</div><div class="line">let enqueue = (callback) =&gt; &#123;</div><div class="line">    //process.nextTick(callback); // NodeJS</div><div class="line">    setTimeout(callback, 1); // Naïve browser solution</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let defer = function () &#123;</div><div class="line">    let pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value);</div><div class="line">                for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    enqueue(function () &#123;</div><div class="line">                        value.then.apply(value, pending[i]);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback, _errback) &#123;</div><div class="line">                let result = defer();</div><div class="line">                _callback = _callback || function (value) &#123;</div><div class="line">                    return value;</div><div class="line">                &#125;;</div><div class="line">                _errback = _errback || function (reason) &#123;</div><div class="line">                    return reject(reason);</div><div class="line">                &#125;;</div><div class="line">                let callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                let errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // XXX</div><div class="line">                    enqueue(function () &#123;</div><div class="line">                        value.then(callback, errback);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = function (value) &#123;</div><div class="line">    if (value &amp;&amp; value.then)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback) &#123;</div><div class="line">            let result = defer();</div><div class="line">            // XXX</div><div class="line">            enqueue(function () &#123;</div><div class="line">                result.resolve(callback(value));</div><div class="line">            &#125;);</div><div class="line">            return result.promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let reject = function (reason) &#123;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback, errback) &#123;</div><div class="line">            var result = defer();</div><div class="line">            // XXX</div><div class="line">            enqueue(function () &#123;</div><div class="line">                result.resolve(errback(reason));</div><div class="line">            &#125;);</div><div class="line">            return result.promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然将需要的回调依照次序添加到了队列中</p>
<p>作者有考虑到一些新的问题，比如</p>
<ul>
<li>callback或者errback必须以同样的顺序被调用</li>
<li>callback或者errback可能会被同时调用</li>
<li>callback或者errback可能会被调用多次</li>
</ul>
<p>于是我们需要找个机会then的回调函数，为了保证当回调函数中程序出错时，可以转入到报错函数中。(其实又是一个库的容错处理，保证代码出错时不中断程序的执行)。</p>
<p>用when方法封装下promise以此阻止错误发生，确保不会有哪些突发性的错误，包括哪些非必需的事件流控制，并且也能使callback和errback各自保持独立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">var when = function (value, _callback, _errback) &#123;</div><div class="line">    var result = defer();</div><div class="line">    var done;</div><div class="line"></div><div class="line">    _callback = _callback || function (value) &#123;</div><div class="line">        return value;</div><div class="line">    &#125;;</div><div class="line">    _errback = _errback || function (reason) &#123;</div><div class="line">        return reject(reason);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    var callback = function (value) &#123;</div><div class="line">        try &#123;</div><div class="line">            return _callback(value);</div><div class="line">        &#125; catch (reason) &#123;</div><div class="line">            return reject(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    var errback = function (reason) &#123;</div><div class="line">        try &#123;</div><div class="line">            return _errback(reason);</div><div class="line">        &#125; catch (reason) &#123;</div><div class="line">            return reject(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    enqueue(function () &#123;</div><div class="line">        ref(value).then(function (value) &#123;</div><div class="line">            if (done)</div><div class="line">                return;</div><div class="line">            done = true;</div><div class="line">            result.resolve(ref(value).then(callback, errback));</div><div class="line">        &#125;, function (reason) &#123;</div><div class="line">            if (done)</div><div class="line">                return;</div><div class="line">            done = true;</div><div class="line">            result.resolve(errback(reason));</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return result.promise;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/kriskowal/q/blob/v1/design/q7.js" target="_blank" rel="external">这一步的完整版</a></p>
<h4 id="六、消息传递"><a href="#六、消息传递" class="headerlink" title="六、消息传递"></a>六、消息传递</h4><p>现在这一步来看，promise已经成为了一个具有接受消息功能的类了。Deferred promise根据获得的消息来执行对应的回调函数，返回对应的值。当你接收到完全成功执行的值，则在then中执行成功的回调函数返回msg；获得错误的值则在then中执行错误回调函数，返回错误的原因</p>
<p>因此我们基本可以认为promise这个类可以接受任何的值，包括”then/when”这些信息。这对于一些非立即执行函数的监听非常有用。举个例子，当你发了一个网络请求，等待返回值才能执行函数。我们等待这个请求的往返的过程中浪费了许多时间，而promise仿佛在电脑中另外开了一个线程进行监听这些返回值，然后执行对应的回调函数(这个例子是自己理解举的，非原文，如有不对，欢迎改正)。</p>
<blockquote>
<p>翻到这里有点崩溃了，捂下脑子，接下去感觉有点头疼了，以后再补吧,因为基本形态的promise已经出来。接下去是另外一种需求的promise了</p>
</blockquote>
<p>接下来我们要包装一种新型的promise，这套promise基于一些能发送任意消息的方法之上，可以满足 “get”, “put”, “post”能发送相应的消息，并且能根据返回结果中执行相应的promise。</p>
<hr>
<p>第一次尝试翻译，真的是个体力活，花了快2天的时间，整个人都是炸的。不过所幸是比以前明白了一些恭喜。<br>原文大概讲解了基本的promise构成，但是现在还是有许多方法并没有分析，接下去我按照自己的想法去实现以下promise.all方法。如果写的不好，欢迎大家指正，帮我进步一下，谢谢。（手动捂脸）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/" itemprop="url">第十六章-站在巨人的肩膀</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T19:47:44+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/" class="leancloud_visitors" data-flag-title="第十六章-站在巨人的肩膀">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  933
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十六章-站在巨人的肩膀"><a href="#—–第十六章-站在巨人的肩膀" class="headerlink" title="—–第十六章-站在巨人的肩膀"></a>—–第十六章-站在巨人的肩膀</h6><p>这章也是本书的最后一章了，看到这里，我不禁问自己两个问题，1.站在经济学的角度，你是否有培养出抽象思考的能力，面对社会的各种现象，是否有一套自己的理论而不是依然人云亦云。2.站在了巨人肩膀上，你是否理解了经济学的思维呢。</p>
<p>第一章节对于人性的分析即生活经济学，让我明白了我们生活中很多不知不觉的习惯其实就是经济学思维的影响，理性与自利的人性，懒惰的天性，信任的价值都是生活中的经济哲学。</p>
<p>第二章的社会经济学则解释了许多社会想象的产生，冷漠的围观者，无情的竞争，残忍的管制都可以由经济学的成本分析。幸运的是，我还相信这中国会变得原来越好，而不是我再网上看到各种黑暗的地方。</p>
<p>第三章政治经济学解释了许多国家政策产生的原因以及我们普通人在这些政策之下受到的影响。无奈的是，虽然我明白了这些政策的最终方向，可是却无法改变自己在大潮下的走势。逆水行舟，不进则退啊。</p>
<p>第四章的法律经济学有时候看得我心惊胆战，世界上是否存在真正的公平与正义，你所看到的真的对的，有价值，有意义的吗？面对真正的选择，跳出自己所在的层面，站在更多更高的角度，也许会发现更多之前没有考虑到的，然后做出的取舍，才显得更加的“公平与正义”。</p>
<p>纵览全书，又人及社会及政治及法律，经济学有由小到大，由点及面，细细解析其所影响的各个层面。归纳出最后4点。</p>
<h5 id="1-人是理性的，自私的。"><a href="#1-人是理性的，自私的。" class="headerlink" title="1. 人是理性的，自私的。"></a>1. 人是理性的，自私的。</h5><p>人们是会思索判断的生物，大多数行为总是为了增添自己（或者自己周围人的福祉）。引申出来的许多懒惰的特性也是由此而来。</p>
<h5 id="2-存在不一定合理，但是存在一定是有原因的。"><a href="#2-存在不一定合理，但是存在一定是有原因的。" class="headerlink" title="2. 存在不一定合理，但是存在一定是有原因的。"></a>2. 存在不一定合理，但是存在一定是有原因的。</h5><p>正是因为行为都是基于理性和自私，所以近年来出现许多冷漠的社会现象（冷眼围观，碰瓷，污蔑）。这些社会现象的出现，都有背后条件的支持————存在不一定合理，但是存在一定是有原因的。</p>
<h5 id="3-好的价值要出现，是有条件的"><a href="#3-好的价值要出现，是有条件的" class="headerlink" title="3. 好的价值要出现，是有条件的"></a>3. 好的价值要出现，是有条件的</h5><p>每个人都希望自己有好的环境，事业上有好的发展，可是这必须你做出一些努力，父母朋友间的互动，自身努力获得好的经济等等。个人小的价值尚且需要这些努力，更大的价值当然需要更困难的条件来支持。所以说，好的价值的出现，是有条件的</p>
<h5 id="4-一件事物的意义，是由其他事物衬托出来的。"><a href="#4-一件事物的意义，是由其他事物衬托出来的。" class="headerlink" title="4. 一件事物的意义，是由其他事物衬托出来的。"></a>4. 一件事物的意义，是由其他事物衬托出来的。</h5><p>最后要说的是我们生活中许多隐含经济学的经验和原则，都是你所在相对环境形成的。如果环境发生改变，则你自己原先所认定的原则自然也会随之发生变化（你要学会拥抱变化）。因此事物的意义，是相对于环境里的各种主管条件，是相对的而不是绝对的。</p>
<p>观点在不断的变化，我们不断的在成长。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/基于vue-cli的webpack优化之路/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/基于vue-cli的webpack优化之路/" itemprop="url">基于vue-cli的webpack优化之路</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-13T23:47:44+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/webpack/" itemprop="url" rel="index">
                    <span itemprop="name">webpack</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/13/基于vue-cli的webpack优化之路/" class="leancloud_visitors" data-flag-title="基于vue-cli的webpack优化之路">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,695
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近的项目度过了开始忙碌的基建期，也慢慢轻松下来，准备记录一下自己最近webpack优化的措施，希望有温故知新的效果。</p>
</blockquote>
<p>项目采用的是vue全家桶，构建配置都是基于vue-cli去改进的。关于原始webpack配置大家可以看下这篇文章<a href="https://github.com/DDFE/DDFE-blog/issues/10" target="_blank" rel="external">vue-cli#2.0 webpack配置分析</a>,文章基本对于文件每行代码都做了详细的解释，有助于更好的理解webpack。<br><a href="https://github.com/linzx1993/APS-ng-vue-/tree/master/mes" target="_blank" rel="external">项目位置链接</a></p>
<p>仔细总结了一下，自己的优化基本还是网上流传的那几点</p>
<ul>
<li>通过 externals 配置来提取常用库，引用cdn</li>
<li>合理配置CommonsChunkPlugin</li>
<li>善用alias</li>
<li>dllplugin启用预编译</li>
<li>happypack多核构建项目</li>
</ul>
<p>不过经过自己的实践最后三点是对自己项目优化最大的。文章也主要对后面几点详细说明一下</p>
<p>原来打包一个项目所需要的时间基本在35-40秒左右(第二次有缓存会稍微快一点)，但是偶尔来一次大姨妈，时间甚至要到50s左右，我也是醉了。不过大家可以期待一下经过下面这三步优化大概需要多久</p>
<h4 id="1-使用dllplugin预编译与引用"><a href="#1-使用dllplugin预编译与引用" class="headerlink" title="1.使用dllplugin预编译与引用"></a>1.使用dllplugin预编译与引用</h4><p>首先为什么要引用Dll？在网上浏览了一些文章后，我发现上除了加快构建速度以外，使用webpack的dll还有一个好处。</p>
<p><strong>Dll打包以后是独立存在的，只要其包含的库没有增减、升级，hash也不会变化，因此线上的dll代码不需要随着版本发布频繁更新。</strong> 因为使用Dll打包的基本上都是独立库文件，这类文件有一个特性就是变化不大。当我们正常打包这些库文件到一个app.js里的时候，由于其他业务文件的改变，影响了缓存对构建的优化，导致每次都要重新去npm包里寻找相关文件。而使用了DLL之后，只要包含的库没有升级， 增减，就不需要重新打包。这样也提高了构建速度。</p>
<p>那么如何使用Dll去优化项目呢<br>首先要建立一个dll的配置文件,引入项目所需要的第三方库。这类库的特点是不需要随着版本发布频繁更新，长期稳定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">const webpack = require(&apos;webpack&apos;);</div><div class="line">const path = require(&apos;path&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    //你需要引入的第三方库文件</div><div class="line">    vendor: [&apos;vue&apos;,&apos;vuex&apos;,&apos;vue-router&apos;,&apos;element-ui&apos;,&apos;axios&apos;,&apos;echarts/lib/echarts&apos;,&apos;echarts/lib/chart/bar&apos;,&apos;echarts/lib/chart/line&apos;,&apos;echarts/lib/chart/pie&apos;,</div><div class="line">      &apos;echarts/lib/component/tooltip&apos;,&apos;echarts/lib/component/title&apos;,&apos;echarts/lib/component/legend&apos;,&apos;echarts/lib/component/dataZoom&apos;,&apos;echarts/lib/component/toolbox&apos;],</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  output: &#123;</div><div class="line">    path: path.join(__dirname, &apos;dist-[hash]&apos;),</div><div class="line">    filename: &apos;[name].js&apos;,</div><div class="line">    library: &apos;[name]&apos;,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  plugins: [</div><div class="line">    new webpack.DllPlugin(&#123;</div><div class="line">      path: path.join(__dirname, &apos;dll&apos;, &apos;[name]-manifest.json&apos;),</div><div class="line">      filename: &apos;[name].js&apos;,</div><div class="line">      name: &apos;[name]&apos;,</div><div class="line">    &#125;),</div><div class="line">  ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>基本配置参数和webpack基本一模一样，相信来看优化的都明白什么意思，我就不解释了。然后执行代码编译文件。<strong>(我的配置文件是放在build里面，下方路径根据项目路径需要变动)</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -p --progress --config build/webpack.dll.config.js</div></pre></td></tr></table></figure></p>
<p>当运行完执行后，会生成两个新文件在目录同级，一个是生成在dist文件夹下的<strong>verdor.js</strong>，里面是刚刚入口依赖被压缩后的代码;一个是dll文件夹下的<strong>verdor-manifest.json</strong>，将每个库进行了编号索引，并且使用的是id而不是name。</p>
<p>接下去你只要去你的webpack配置文件的里的plugin中添加一行代码就ok了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">const manifest = require(&apos;./dll/vendor-manifest.json&apos;);</div><div class="line">...</div><div class="line">...,</div><div class="line">plugin:[</div><div class="line">    new webpack.DllReferencePlugin(&#123;</div><div class="line">        context: __dirname,</div><div class="line">        manifest,</div><div class="line">    &#125;),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这时候再执行webpack命令，可以发现时间直接从40秒锐减到了18-20s左右，整整快了一倍有木有(不知道是不是因为自己依赖库太多了才这样的，手动捂脸)。</p>
<h4 id="2-happypack多线程编译"><a href="#2-happypack多线程编译" class="headerlink" title="2.happypack多线程编译"></a>2.happypack多线程编译</h4><p>一般node.js是单线程执行编译，而<a href="https://github.com/amireh/happypack" target="_blank" rel="external">happypack</a>则是启动node的多线程进行构建，大大提高了构建速度。使用方法也比较简单。以我项目为例,在插件中new一个新的happypack进程出来，然后再使用使用loader的地方替换成对应的id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var HappyPack = require(&apos;happypack&apos;);</div><div class="line">...</div><div class="line">...</div><div class="line">modules:&#123;</div><div class="line">    rules : [</div><div class="line">        ...</div><div class="line">        &#123;</div><div class="line">            test: /\.js$/,</div><div class="line">            loader:[ &apos;happypack/loader?id=happybabel&apos;],</div><div class="line">            include: [resolve(&apos;src&apos;)]</div><div class="line">        &#125;,</div><div class="line">        ...</div><div class="line">    ]</div><div class="line">&#125;,</div><div class="line">...</div><div class="line">...</div><div class="line">plugin:[</div><div class="line">    //happypack对对 url-loader,vue-loader 和 file-loader 支持度有限，会有报错，有坑。。。</div><div class="line">    new HappyPack(&#123;</div><div class="line">          id: &apos;happybabel&apos;,</div><div class="line">          loaders: [&apos;babel-loader&apos;],</div><div class="line">          threads: 4,//HappyPack 使用多少子进程来进行编译</div><div class="line">    &#125;),</div><div class="line">    new HappyPack(&#123;</div><div class="line">          id: &apos;scss&apos;,</div><div class="line">          threads: 4,</div><div class="line">          loaders: [</div><div class="line">                &apos;style-loader&apos;,</div><div class="line">                &apos;css-loader&apos;,</div><div class="line">                &apos;sass-loader&apos;,</div><div class="line">          ],</div><div class="line">    &#125;)</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这时候再去执行编译webpack的代码，打印出来的console则变成了另外一种提示。而编译时间大概从20s优化到了15s左右(感觉好像没有网上说的那么大，不知道是不是因为本身js比重占据太大的缘故)。</p>
<h4 id="3-配合resolve，善用alias"><a href="#3-配合resolve，善用alias" class="headerlink" title="3.配合resolve，善用alias"></a>3.配合resolve，善用alias</h4><p>本来是没有第三点的，只不过在搜索网上webpack优化相关文章的时候，看到用人提到把引入文件改成库提供的文件(原理我理解其实就是1.先通过resolve指定文件寻找位置，减小搜索范围；2.直接根据alias找到库提供的文件位置)。</p>
<p>vue-cli配置文件中提示也有提到这一点，就是下面这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">resolve: &#123;</div><div class="line">    //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名</div><div class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],</div><div class="line">    //模块别名定义，方便后续直接引用别名，无须多写长长的地址</div><div class="line">    alias: &#123;</div><div class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,//就是这行代码，提供你直接引用文件</div><div class="line">      &apos;@&apos;: resolve(&apos;src&apos;),</div><div class="line">    &#125;</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>然后我将其他所有地方关于vue的引用都替换成了vue$之后，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// import &apos;vue&apos;;</div><div class="line">import &apos;vue/dist/vue.esm.js&apos;;</div></pre></td></tr></table></figure></p>
<p>时间竟然到了12s，也是把我吓了一跳。。。</p>
<p>然后我就把jquery，axios，vuex等等全部给替换掉了。。。大概优化到了9s-11s左右，美滋滋，O(∩_∩)O~~</p>
<h4 id="4-webpack3升级"><a href="#4-webpack3升级" class="headerlink" title="4.webpack3升级"></a>4.webpack3升级</h4><p>本来是没第四点，刚刚看到公众号推出来一篇文章讲到升级到webpack3的一些新优点，比如<strong>Scope Hoisting</strong>(webpack2升级到webpack3基本上没有太大问题)。通过添加一个新的插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//  2017-08-13配合最新升级的webpack3提供的新功能，可以使压缩的代码更小，运行更快</div><div class="line">...</div><div class="line">plugin : [</div><div class="line">    new webpack.optimize.ModuleConcatenationPlugin(),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>不过在添加这行代码之后，构建时间并没有太大变化，不过运行效率没试过，不知道新的效果怎么样</p>
<p>好了基本上感觉就是以上这些效果对项目的优化最大，虽然没有到网上说的那种只要3~4秒时间那么变态，不过感觉基本8,9秒的时间也可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/12/重温vue双向绑定原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/12/重温vue双向绑定原理/" itemprop="url">重温vue双向绑定原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-12T23:47:44+08:00">
                2017-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index">
                    <span itemprop="name">vue</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/12/重温vue双向绑定原理/" class="leancloud_visitors" data-flag-title="重温vue双向绑定原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,224
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>摘要：因为项目刚开始用的vue框架，所以早期也研究了一下他的代码看过相关文章的解析，说说也能说个七七八八。不过今天再去看以前的demo的时候，发现忽然一知半解了，说明当时可能也没有理解透，所以写篇文章让自己理解的更深一些。</p>
</blockquote>
<p>本篇文章大多数知识点实在学习了这篇<a href="http://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" target="_blank" rel="external">Vue.js双向绑定的实现原理</a>之后避免遗忘，所以写这个温故知新，加强理解。</p>
<p><a href="https://github.com/linzx1993/APS-ng-vue-/tree/master/mes" target="_blank" rel="external">项目位置链接</a></p>
<hr>
<h4 id="一、访问器属性"><a href="#一、访问器属性" class="headerlink" title="一、访问器属性"></a>一、访问器属性</h4><p>如果稍微看过相关文章的人都知道vue的实现是依靠Object.defineproperty()来实现的。每个对象都有自己内置的set和get方法，当每次使用set时，去改变引用该属性的地方，从而实现数据的双向绑定。简单举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const obj = &#123;&#125;;</div><div class="line">Object.defineProperty(obj,&apos;hello&apos;,&#123;</div><div class="line">    get(value)&#123;</div><div class="line">        console.log(&quot;啦啦啦，方法被调用了&quot;);</div><div class="line">    &#125;,</div><div class="line">    set(newVal,oldVal)&#123;</div><div class="line">        console.log(&quot;set方法被调用了，新的值为&quot; + newVal)</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">obj.hello; //get方法被调用了</div><div class="line">obj.hello = &quot;1234&quot;; //set方法被调用了</div></pre></td></tr></table></figure>
<h4 id="二、极简双向绑定的实现"><a href="#二、极简双向绑定的实现" class="headerlink" title="二、极简双向绑定的实现"></a>二、极简双向绑定的实现</h4><p>基于这个原理，如果想实现显示文字根据输入input变化，实现一个简单版的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; id=&quot;a&quot;/&gt;</div><div class="line">&lt;span id=&quot;b&quot;&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">    const obj = &#123;&#125;;</div><div class="line">    Object.defineProperty(obj,&apos;hello&apos;,&#123;</div><div class="line">        get()&#123;</div><div class="line">            console.log(&quot;啦啦啦，方法被调用了&quot;);</div><div class="line">        &#125;,</div><div class="line">        set(newVal)&#123;</div><div class="line">            document.getElementById(&apos;a&apos;).value = newVal;</div><div class="line">            document.getElementById(&apos;b&apos;).innerHTML = newVal;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">    document.addEventListener(&apos;keyup&apos;,function(e)&#123;</div><div class="line">        obj.hello = e.target.value;</div><div class="line">    &#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>上面这个实例实现的效果是：随着文本框输入文字的变化，span会同步显示相同的文字内容。同时在控制台用js改变obj.hello，视图也会更新。这样就实现了view-&gt;model，model-&gt;view的双向绑定。</p>
<h4 id="三、拆解任务，实现vue的双向数据绑定"><a href="#三、拆解任务，实现vue的双向数据绑定" class="headerlink" title="三、拆解任务，实现vue的双向数据绑定"></a>三、拆解任务，实现vue的双向数据绑定</h4><p>我们最终实现下面vue的效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; v-model=&quot;text&quot;/&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">const vm = new Vue(&#123;</div><div class="line">    id : &quot;app&quot;,</div><div class="line">    data : &#123;</div><div class="line">        text : &quot;hello world&quot;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>1.输入框的文本与文本节点的data数据绑定<br>2.输入框的内容发生变化时，data中的数据也发生变化，实现view-&gt;model的变化<br>3.data中的数据发生变化时，文本节点的内容同步发生变化，实现model-&gt;view的变化</p>
<p>要实现1的要求，则又涉及到了dom的编译，其中有一个DocumentFragment的知识点。</p>
<h4 id="四、DocumentFragment"><a href="#四、DocumentFragment" class="headerlink" title="四、DocumentFragment"></a>四、DocumentFragment</h4><p>众所周知，vue吸收了react虚拟DOM的优点，使用DocumentFragment处理节点，其性能和速度远胜于直接操作dom。vue进行编译时，就是将所有挂载在dom上的子节点进行劫持到使用DocumentFragment处理节点，等到所有操作都执行完毕，将DocumentFragment再一模一样返回到挂载的目标上。</p>
<p>先实现一段劫持函数，将要操作的dom全部劫持到DocumentFragment中，然后再append会原位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">    &lt;input type=&quot;text&quot; v-model=&quot;text&quot;/&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">const app = document.getElementById(&quot;app&quot;);</div><div class="line">const nodetoFragment = (node) =&gt; &#123;</div><div class="line">    const flag = document.createDocumentFragment();</div><div class="line">    let child;</div><div class="line">    whild(child = node.firstChild)&#123;</div><div class="line">        flag.appendChild(child);//不断劫持挂载元素下的所有dom节点到创建的DocumentFragment</div><div class="line">    &#125;</div><div class="line">    return flag</div><div class="line">&#125;</div><div class="line">const dom = nodetoFragment(app);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h4 id="五、数据初始化绑定"><a href="#五、数据初始化绑定" class="headerlink" title="五、数据初始化绑定"></a>五、数据初始化绑定</h4><p>当已经获取到所有的dom元素之后，则需要对数据进行初始化绑定，这里简单涉及到了模板的编译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">//  编译HTML模板</div><div class="line">	const compile = (node,vm) =&gt; &#123;</div><div class="line">		const regex = /\&#123;\&#123;(.*)\&#125;\&#125;/;//为临时正则表达式，为demo而生</div><div class="line">		//如果节点类型为元素的话</div><div class="line">		if(node.nodeType === 1)&#123;</div><div class="line">			const attrs = node.attributes;//学到一个新属性。。。</div><div class="line">			for(let i = 0;i &lt; attrs.length; i++)&#123;</div><div class="line">				let attr = attrs[i];</div><div class="line">				if(attr.nodeName === &quot;v-model&quot;)&#123;</div><div class="line">					let name = attr.nodeValue;</div><div class="line">					node.addEventListener(&quot;input&quot;,function (e) &#123;</div><div class="line">					    vm.data[name] = e.target.value;</div><div class="line">					&#125;)</div><div class="line">					node.value = vm.data[name];</div><div class="line">					node.removeAttribute(&quot;v-model&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		//如果节点类型为文本的话</div><div class="line">		if(node.nodeType === 3)&#123;</div><div class="line">			if(regex.test(node.nodeValue))&#123;</div><div class="line">				let name = RegExp.$1;//获取搭配匹配的字符串，又学到了。。。</div><div class="line">				name = name.trim();</div><div class="line">				node.nodeValue = vm.data[name];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	//劫持挂载元素到虚拟dom</div><div class="line">	let nodeToFragment = (node,vm) =&gt; &#123;</div><div class="line">		const flag = document.createDocumentFragment();</div><div class="line">		let child;</div><div class="line">		while(child = node.firstChild)&#123;</div><div class="line">			compile(child,vm);//绑定数据，插入到虚拟DOM中</div><div class="line">			flag.appendChild(child);</div><div class="line">		&#125;</div><div class="line">		return flag;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	//初始化</div><div class="line">	class Vue &#123;</div><div class="line">		constructor(option)&#123;</div><div class="line">			this.data = option.data;</div><div class="line">			let id = option.el;</div><div class="line">			let dom = nodeToFragment(document.getElementById(id),this);</div><div class="line">			document.getElementById(id).appendChild(dom);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	const vm = new Vue(&#123;</div><div class="line">		el : &quot;app&quot;,</div><div class="line">		data : &#123;</div><div class="line">			text : &quot;hello world&quot;</div><div class="line">		&#125;</div><div class="line">	&#125;)</div></pre></td></tr></table></figure>
<p>通过以上代码先实现了第一个要求，文本框和文本节点已经出现了hello woeld了</p>
<h4 id="六、响应式的数据绑定"><a href="#六、响应式的数据绑定" class="headerlink" title="六、响应式的数据绑定"></a>六、响应式的数据绑定</h4><p>接下来我们要实现数据双向绑定的第一步，即view-&gt;model的绑定。根据之前那个简单的例子看到，我们实时获取input中的值，通过Object.defineProperty将data中的text设置为vm的访问器属性，通过set方法，当我们在设置vm.data的值时，实现数据层的绑定。在这一步，set中要做的操作是更新属性的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let defineReactive = (obj,key,val) =&gt; &#123;</div><div class="line">    Object.defineProperty(obj,key,&#123;</div><div class="line">        get(val)&#123;</div><div class="line">            return val;</div><div class="line">        &#125;</div><div class="line">    	set(newVal,oldVal)&#123;</div><div class="line">    	    if(newVal === oldVal) return;</div><div class="line">    	    val = newVal;</div><div class="line">    	    console.log(val);</div><div class="line">    	&#125;</div><div class="line">    &#125;)</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//监听数据</div><div class="line">let observe = (obj,vm) =&gt; &#123;</div><div class="line">	Object.keys(obj).forEach((key)=&gt;&#123;</div><div class="line">		defineReactive(vm.data,key,obj[key]);</div><div class="line">	&#125;)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="七、订阅-发布模式（subscribe-amp-publish）"><a href="#七、订阅-发布模式（subscribe-amp-publish）" class="headerlink" title="七、订阅/发布模式（subscribe&amp;publish）"></a>七、订阅/发布模式（subscribe&amp;publish）</h4><p> text 属性变化了，set方法触发了，可以通过view层的改变实时改变数据，可是并没有改变文本节点的数据。一个新的知识点：订阅发布模式。</p>
<p> 订阅发布模式（又称为观察者模式）定义了一种一对多的关系，让多个观察者同时监听一个主题对象，这个主体对象的改变会通知所有观察者对象。</p>
<p> 发布者发出通知=&gt;主题对象收到通知并推送给订阅者=&gt;订阅者执行操作<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"> //	三个订阅者</div><div class="line">	let sub1 = &#123;updata()&#123;console.log(1);&#125;&#125;;</div><div class="line">	let sub2 = &#123;updata()&#123;console.log(2);&#125;&#125;;</div><div class="line">	let sub3 = &#123;updata()&#123;console.log(3);&#125;&#125;;</div><div class="line"></div><div class="line">	//  一个主题发布器</div><div class="line">	class Dep&#123;</div><div class="line">		constructor()&#123;</div><div class="line">			this.subs = [sub1,sub2,sub3];</div><div class="line">		&#125;</div><div class="line">		notify()&#123;</div><div class="line">			subs.forEach((sub) =&gt; &#123;</div><div class="line">				sub.updata();</div><div class="line">			&#125;)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	const dep = new Dep();</div><div class="line">//	一个发布者</div><div class="line">	const pub = &#123;</div><div class="line">		publish()&#123;</div><div class="line">		    dep.notipy();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	pub.publish();</div></pre></td></tr></table></figure></p>
<p>上图为一个简单实例，发布者执行发布命令，所有这个主题的订阅者执行更新操作。接下去我们要做的就是，当set方法触发后，input作为发布者，改变了text属性；而文本节点作为订阅者，在收到消息后执行更新操作。</p>
<h4 id="八、双向绑定的实现"><a href="#八、双向绑定的实现" class="headerlink" title="八、双向绑定的实现"></a>八、双向绑定的实现</h4><p>每次new一个新的vue对象时，主要是做了两件事，一件是监听数据：observer(监听数据)，第二个是编译HTML，nodeToFragement(id)。</p>
<p>在监听数据的过程中，会为data中的每一个属性生成一个主题对象。</p>
<p>而在编译HTML的过程中，会为每个与数据绑定的相关节点生成一个订阅者watcher，订阅者watcher会将自己订阅到相应属性的dep中。</p>
<p>在前面的方法中已经实现了：修改输入框内容=&gt;再时间回调中修改属性值=&gt;触发属性的set方法。</p>
<p>接下来要做的是发出通知dep.notify=&gt;发出订阅者的uodate方法=&gt;更新视图。</p>
<p>那么如何将watcher添加到关联属性的dep中呢。</p>
<p>编译HTML过程中，为每一个与data关联的节点生成一个watcher，那么watcher中又发生了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//  每一个属性节点的watcher</div><div class="line">class Watcher&#123;</div><div class="line">	constructor(vm,node,name)&#123;</div><div class="line">		Dep.target = this;</div><div class="line">		this.name = name;</div><div class="line">		this.node = node;</div><div class="line">		this.vm = vm;</div><div class="line">		this.update();</div><div class="line">		Dep.target = null;</div><div class="line">	&#125;</div><div class="line">	update()&#123;</div><div class="line">		//获得最新值，然后更新视图</div><div class="line">		this.get();</div><div class="line">		this.node.nodeValue = this.value;</div><div class="line">	&#125;</div><div class="line">	get()&#123;</div><div class="line">		this.value = this.vm.data[this.name];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在编译HTML的过程中，生成watcher<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let complie = (node,vm)&#123;</div><div class="line">    ......</div><div class="line">    //如果节点类型为文本的话</div><div class="line">    if(node.nodeType === 3)&#123;</div><div class="line">	    if(regex.test(node.nodeValue))&#123;</div><div class="line">	        let name = RegExp.$1;</div><div class="line">	        name = name.trim();</div><div class="line">            node.nodeValue = vm.data[name];</div><div class="line">            </div><div class="line">            new Watcher(vm,node,name);//在此处添加订阅者</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先将自己赋给了一个全局变量Dep.target;然后执行了uodate方法，进而执行了get方法，读取了vm的访问器属性，从而触发了访问器属性的get方法，get方法将相应的watcher添加到对应访问器属性的dep中。再次，获取属性的值，然后更新视图。最后将dep.target设置为空，是因为这是个全局变量也是watcher与dep之间唯一的桥梁，任何时间都只能保证只有一个值。（其实就是说全局一个主题，每个订阅者和发布者都是通过这个主题进行沟通。当执行代码时，这个主题接受到一个发布通知，通知完所有订阅者，然后注销掉，用于下一个通知发布。啰嗦了一段就是想讲为什么要设置Dep.target = null）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//  一个主题发布器</div><div class="line">class Dep()&#123;</div><div class="line">    constructor()&#123;</div><div class="line">        this.subs = [];</div><div class="line">    &#125;</div><div class="line">    notify()&#123;</div><div class="line">        this.subs.forEach((sub) =&gt; &#123;</div><div class="line">            sub.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addSub(sub)&#123;</div><div class="line">        this.subs.push(sub);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let defineReactive = (obj,key,val) =&gt; &#123;</div><div class="line">    let dep = new Dep();</div><div class="line">    Object.defineProperty(obk,key,&#123;</div><div class="line">        get()&#123;</div><div class="line">            if(dep.target) dep.addSub(dep.target);</div><div class="line">        &#125;        </div><div class="line">        set(newVal,oldVal)&#123;</div><div class="line">            if(newVal === oldVal) return;</div><div class="line">            val = newVal;</div><div class="line">            dep.notify();</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，hello world 双向绑定就基本实现了。文本内容会随输入框内容同步变化，在控制器中修改 vm.text 的值，会同步反映到文本内容中。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/07/15.生活中的经济学原理-----以管窥天？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/15.生活中的经济学原理-----以管窥天？/" itemprop="url">第十五章-以管窥天</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T13:47:44+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/07/15.生活中的经济学原理-----以管窥天？/" class="leancloud_visitors" data-flag-title="第十五章-以管窥天">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  582
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十五章-以管窥天？"><a href="#—–第十五章-以管窥天？" class="headerlink" title="—–第十五章-以管窥天？"></a>—–第十五章-以管窥天？</h6><p>工作也慢慢不忙了，生活也慢慢恢复原样了，回到了原来的轨道上面去了。人们的在思考与做每一个决定都是有他的利弊，当下做出的选择。比起做决定，更大的收货是你在做决定时的思维模式。不管你最后的结果怎么样，当你在面对各种现象和问题时，有自己的认知和思索方式，便是你独有的财富。</p>
<p>本章主要想讲述的其实也是这种思维模式的重要性。我们一生中会做出很多选择，你自己有时候也不知道自己做的选择是否正确，就像自己最近感情上做出的选择，你放弃了很多的同时，也会有相应许多的得到的，也许再过了一段时间之后，你会后悔或者遗憾当时你做的选择，但是这就是你在当时情境下自己做的最好的决定。<strong>很多事情有两个选项给你选已经是很幸福的事情了。</strong></p>
<p>经济学在生活中的很多表现其实也就是帮我们做出取舍。看电影，吃饭，睡觉等许多事情不仅仅是由事情本身所决定的，更多会受到周围工作，场景，同事等因素影响。经济学擅长将各个因素抽象化，图表化在心中列出来。自己在思考问题时，可以明确，精致，有效的掌握每一个环节，从而归纳出有意义的结果。也许也会在思考对比的过程中，想出更好的替代方案。</p>
<p>这篇看完后其实没有太多可以分析，但是细细思考，最重要的早已在生活中潜移默化的影响了我们。以后在做每个决定时，独立全面的思考决定所带来的利弊，也许几年后在后悔自己sb的举动，但是至少你曾经细致的去想过每个选项，在你当时的情境下做出最好的选择。并且如果你真的当你思考全面当作出后，也不要再纠结了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/27/14.生活中的经济学原理-----司法女神的举止/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/14.生活中的经济学原理-----司法女神的举止/" itemprop="url">第十四章-司法女神的举止</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T13:47:44+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/27/14.生活中的经济学原理-----司法女神的举止/" class="leancloud_visitors" data-flag-title="第十四章-司法女神的举止">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  879
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十四章-司法女神的举止"><a href="#—–第十四章-司法女神的举止" class="headerlink" title="—–第十四章-司法女神的举止"></a>—–第十四章-司法女神的举止</h6><p>好久好久没有看书了，一是因为最近的项目是在是太紧张了，要赶在deadline前完成，同时手贱半个月前空的时候接了个私活，更加忙的不可开交。好不容易等忙完了，好了，吃了个特辣的香锅整个人身体垮了。也算明白了一个道理，欠的账总是要还的。你加班忙碌期的疲惫会在你松懈下的那一刻爆发不来的。</p>
<h5 id="好了，回到正题"><a href="#好了，回到正题" class="headerlink" title="好了，回到正题"></a>好了，回到正题</h5><hr>
<p>这是法律经济学的最后一篇。之前的对此有的印象似乎已经有点模糊了。只记得法律经济学告诉我们许多法律上的制定可以由经济效益为出发点进行考虑，会发现许多案例有不一样的发现。</p>
<p>本章最明显的一个例子是火车撞小孩的故事，一个小孩在看清楚了告示之后在不会有火车经过的铁轨上玩耍，而另外5个小孩却仍然在火车要通过的铁道上玩耍。没过多久，火车匆匆而至，身为扳道工的你是否会让火车转入另一条，去撞那位对的小孩呢??</p>
<p>这个故事很久之前就看到过，我心目里的答案一直不该，因为一个人做错事就应该受到惩罚，凭什么让对的人替错的人去牺牲生命。法律上对就是对，错就是错，如果法律不支持对的事情，那么法律的尊严将消失的无影无踪。在文中则给出了另外几种思路，比如从小孩成长后的价值，5个富孩子家庭背景去弥补穷孩子的损失。这几种说法虽然角度独特，却也没有给予我震动感。不过当文中说道<strong>如果是100个孩子呢，1000个孩子呢，那么你是否还会去撞吗？</strong> 我感觉我的想法已经改变了，我也许会去牺牲那个人吧。法律固然是公平与正义的，可是在规则与例外之间的取舍，却显得更加慎重与微妙。（好吧，人们总能自圆其说，找到理由来暗示自己）</p>
<p>法律中一些规则的制定是否需要考虑情理之外的的东西。以火车撞小孩子为例，当你动摇了内心不扳轨道的决定，就说明你已经考虑了情理之外的东西，而不止是法律的公平正义了。现实中其实的确是有许多规则属于这种。对于“恋童癖”判处重刑甚至死刑就属于这个，需要加重惩罚来进行宣示警醒的作用，防患于未然，才能更好的保护孩子。而对未成年人减轻惩罚，对犯人减刑，则是因为他们未来可能会有更大更好的价值。不同的表现都是具有不同的价值的，惩罚是善后的补救措施，遏阻则是着眼于未来长远利益的展望。</p>
<p>哎，真的是感觉从法律经济学的角度去考虑，很多事情则都没有了法律的公平正义可言了。司法女神的尊严真的因为各种各样的情理，价值受到了极大的挑战啊。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/13.生活中的经济学原理-----司法有价吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/13.生活中的经济学原理-----司法有价吗？/" itemprop="url">第十三章-司法有价吗？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T13:47:44+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/07/06/13.生活中的经济学原理-----司法有价吗？/" class="leancloud_visitors" data-flag-title="第十三章-司法有价吗？">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  805
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十三章-司法有价吗？"><a href="#—–第十三章-司法有价吗？" class="headerlink" title="—–第十三章-司法有价吗？"></a>—–第十三章-司法有价吗？</h6><p>万万没有想到距离上一篇写的文章已经过去了一个月了，看样子最近这个月的工作任务真是太大了。如果用经济学的角度去解析，之所以这么久不工作，只因为我写文章带来的收益没有我最近做项目带来的收益大。我看书加写文章所付出虽然看上去只有一小时的成本，可是这一小时从当下来看，没有为我带来任何收益，我自然会将事情的顺序排在后面。</p>
<hr>
<p>好了，回到正题，本篇讲的是法律经济学。其实在看书的途中，我也越来越感受到文章想表达的东西，在我理解来看，其实就是成本和收益的问题。付出多少成本，拿到多少收益，怎么样实现最大成本收益比，其实就是以经济学的角度去考虑问题。文中提出来的几个事例，如违章过马路收取过路费，有些人愿意缴费用来赶时间，有人愿意0成本过马路，其实都是各自对自己时间效益的评估。政府采用收费来限制行人，而不是竖警示牌，宣传教育，也是因为觉得这样子的收益比是最高的<strong>。所以司法有价吗？缴费违章过马路对吗？过马路这件事当然不对，违法；但是我缴费也是合法维护了规则秩序，所以最终这件事只不过合乎法，违于礼而已。</strong></p>
<p>文中还有一个教育部长的例子也更加证明了经济学在政府中政策的影响。教育部长站在教育领域，希望政府支持更多的精力花在特殊儿童的教育上，他拿出美国一位残疾儿童在三位医护人员的帮助下获取文学奖的例子为佐证，希望发掘更多特殊人才的潜力。可是在商言商，特殊教育固然重要，可是教育领域中的童年教育，初中教育也很重要，如果把资源集中在这一块，是不是也能发挥更多的用处呢。如果在提高一层，站在国家角度，你‘教育‘重要，那么‘环保’重要吗？‘安防’重要吗？等等重要吗？这么一对比，花在特殊教育上的资源还值得吗？教育部长的话站在自身的角度当然也没有错，合乎情理，只不过一旦吧层次提高站在更高的决策位角度，许多问题就从绝对性变为了相对性。<strong>所以教育和面包谁更重要呢？</strong></p>
<p>随着这本书越读越多，其实你也能明白，真正的公平正义是没有的，对公平正义的追求，是建立在一个稳定，成熟的社会，和其背后所愿意付出的资源。<strong>司法女神希望世界充满公平，可是她也只能环抱胸前有限的空间。</strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/header.jpg"
               alt="linzx" />
          <p class="site-author-name" itemprop="name">linzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
    <div id="music163player">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=406238&auto=0&height=66"></iframe>
        </iframe>
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">linzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("l3F7nF9MmsyTnvM5rI1g7V9s-gzGzoHsz", "TyY2L80HJkN4VjXnTqdDxuWw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  <div class="bg_content">
      <canvas id="canvas"></canvas>
  </div>
  <script>
  'use strict';

      var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

      function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

      function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

      function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

      var Circle = function () {
         function Circle(x, y) {
              _classCallCheck(this, Circle);

              this.x = x;
              this.y = y;
              this.r = Math.random() * 10;
              this._mx = Math.random();
              this._my = Math.random();
          }

         _createClass(Circle, [{
              key: 'drawCircle',
              value: function drawCircle(ctx) {
                  ctx.beginPath();
                  //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
                  ctx.arc(this.x, this.y, this.r, 0, 360);
                  ctx.closePath();
                  ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
                  ctx.fill();
              }
          }, {
              key: 'drawLine',
              value: function drawLine(ctx, _circle) {
                  var dx = this.x - _circle.x;
                  var dy = this.y - _circle.y;
                  var d = Math.sqrt(dx * dx + dy * dy);
                  if (d < 150) {
                      ctx.beginPath();

                      ctx.moveTo(this.x, this.y); //起始点
                      ctx.lineTo(_circle.x, _circle.y); //终点
                      ctx.closePath();
                      ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
                      ctx.stroke();
                  }
              }


          }, {
              key: 'move',
              value: function move(w, h) {
                  this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;
                  this._my = this.y < h && this.y > 0 ? this._my : -this._my;
                  this.x += this._mx / 2;
                  this.y += this._my / 2;
              }
          }]);

          return Circle;
      }();



      var currentCirle = function (_Circle) {
          _inherits(currentCirle, _Circle);

          function currentCirle(x, y) {
              _classCallCheck(this, currentCirle);

              return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));
          }

          _createClass(currentCirle, [{
              key: 'drawCircle',
              value: function drawCircle(ctx) {
                  ctx.beginPath();

                  //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
                  this.r = 8;
                  ctx.arc(this.x, this.y, this.r, 0, 360);
                  ctx.closePath();
                  //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
                  ctx.fillStyle = 'rgba(255, 77, 54, 0.6)';
                  ctx.fill();
              }
          }]);

          return currentCirle;
      }(Circle);


      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext('2d');
      var w = canvas.width = canvas.offsetWidth;
      var h = canvas.height = canvas.offsetHeight;
      var circles = [];
      var current_circle = new currentCirle(0, 0);

      var draw = function draw() {
          ctx.clearRect(0, 0, w, h);
          for (var i = 0; i < circles.length; i++) {
              circles[i].move(w, h);
              circles[i].drawCircle(ctx);
              for (var j = i + 1; j < circles.length; j++) {
                  circles[i].drawLine(ctx, circles[j]);
              }
          }
          if (current_circle.x) {
              current_circle.drawCircle(ctx);
              for (var k = 1; k < circles.length; k++) {
                  current_circle.drawLine(ctx, circles[k]);
              }
          }
          requestAnimationFrame(draw);
      };

      var init = function init(num) {
          for (var i = 0; i < num; i++) {
              circles.push(new Circle(Math.random() * w, Math.random() * h));
          }
          draw();
      };
      window.addEventListener('load', init(60));
      window.onmousemove = function (e) {
          e = e || window.event;
          current_circle.x = e.clientX;
          current_circle.y = e.clientY;
      };
      window.onmouseout = function () {
          current_circle.x = null;
          current_circle.y = null;
      };
  </script>
</body>
</html>
