<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, linzx" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="linzx">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="linzx">
<meta property="og:description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="linzx">
<meta name="twitter:description" content="linzx linzhixiang 林智翔 linzx1993@gmail.com">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>linzx</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?93e1e7523d9fccc42d9201ace7ca982a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">linzx</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/13/一步步实现一个简单的router插件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/一步步实现一个简单的router插件/" itemprop="url">js中数组的原生方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T13:47:44+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/01/13/一步步实现一个简单的router插件/" class="leancloud_visitors" data-flag-title="js中数组的原生方法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  802
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>单页应用在随着框架的诞生已经是大趋势，自己平时在项目中也已经用了不少vur-router的代码了。用久了自然对其中的实现好奇了起来，于是想着自己能不能做出一个简单的vue-router。一开始扒了源码研究，实在是看不懂。于是从一篇篇文章开始慢慢补充起自己的基础。</p>
</blockquote>
<h4 id="一、写一个最简单的前端路由"><a href="#一、写一个最简单的前端路由" class="headerlink" title="一、写一个最简单的前端路由"></a>一、写一个最简单的前端路由</h4><p>如果使用过vue-router的人应该知道，Router插件是通过切换hash值来切换页面的。而浏览器则提供了一个<strong>hashchange</strong>的回调方法监听的hash值的变化。我们可以就这个原生API实现一个简单的前端路由。</p>
<blockquote>
<p>之所以用这个API作为我们第一个出场嘉宾，其好处是可以兼容低版本的IE8浏览器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#/router1&quot;&gt;router1&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#/router2&quot;&gt;router2&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">--------</div><div class="line"></div><div class="line">class Router &#123;</div><div class="line">    constructor(router = &#123;&#125;)&#123;</div><div class="line">    	this.router = router;</div><div class="line">    	this.init();</div><div class="line">    &#125;</div><div class="line">    refresh()&#123;</div><div class="line">        let url = window.location.hash.slice(1) || &quot;/&quot;;</div><div class="line">        if(this.router[url])&#123;</div><div class="line">        	this.router[url]();</div><div class="line">        &#125;else&#123;</div><div class="line">        	throw new Error(&quot;It isn&apos;t  a router name that registered&quot;);</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;</div><div class="line">    init()&#123;</div><div class="line">    	window.addEventListener(&quot;hashchange&quot;,this.refresh.bind(this),false);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function changeContent(text)&#123;</div><div class="line">	document.getElementById(&quot;content&quot;).innerText = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let router = new Router(&#123;</div><div class="line">    &quot;/&quot;()&#123;</div><div class="line">    	changeContent(&apos;home&apos;)</div><div class="line">    &#125;,</div><div class="line">    &apos;/router1&apos;()&#123;</div><div class="line">    	changeContent(&apos;router1&apos;)</div><div class="line">    &#125;,</div><div class="line">    &apos;/router1&apos;()&#123;</div><div class="line">    	changeContent(&apos;router2&apos;)</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当浏览器监听到hash值发生改变之后，自动调用对应路由提供的回调，这样子就出现了一个简单的单页路由demo。</p>
<h4 id="二、实现一个简单的H5版本的前端路由"><a href="#二、实现一个简单的H5版本的前端路由" class="headerlink" title="二、实现一个简单的H5版本的前端路由"></a>二、实现一个简单的H5版本的前端路由</h4><p>随着HTML5的发布，我们则多了一个新的选择<strong>history</strong>。</p>
<p>浏览器原生的<strong>history</strong>对象为我们提供了一些新的方法如下,具体意思基本上也可以做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">history.go();   //加载 history 列表中的某个具体页面。</div><div class="line">history.back(); //加载 history 列表中的前一个 URL,等同于history.go(-1)。</div><div class="line">history.foward();   //加载 history 列表中的下一个 URL,等同于history.go(1)。</div><div class="line">history.pushState(state,title,url);    //添加一条页面地址记录</div><div class="line">history.replaceState(state,title,url); //更新当前的历史地址记录</div></pre></td></tr></table></figure></p>
<p>这里再额外说一句<strong>pushState</strong>方法和<strong>replaceState</strong>的区别，从网上找了一张图来表示</p>
<p><img src="https://raw.githubusercontent.com/linzx1993/linzx1993.github.io/master/images/differState.jpg" alt="image"></p>
<p>pushState()是在history栈中添加一个地址并同时跳往该地址，replaceState()是直接替换当前地址为新地址。</p>
<p>每当你使用<strong>pushState()</strong>或者<strong>replaceState()</strong>方法时，会触发<strong>popstate</strong>事件的回调</p>
<p>然后我们以这两个方法为基础，重新写一个Router的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;#/&quot;&gt;home&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#/router1&quot;&gt;router1&lt;/a&gt;</div><div class="line">&lt;a href=&quot;#/router2&quot;&gt;router2&lt;/a&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">--------</div><div class="line">class Router&#123;</div><div class="line">    constructor(router = &#123;&#125;)&#123;</div><div class="line">        this.router = router;</div><div class="line">        this.init();</div><div class="line">    &#125;</div><div class="line">    route(path,cb)&#123;</div><div class="line">        this.router[path] = cb || function () &#123;</div><div class="line">        		throw new Error(&quot;please give a callback&quot;);</div><div class="line">        	&#125;;</div><div class="line">    	&#125;</div><div class="line">    refresh(state)&#123;</div><div class="line">        let url = state.path || &quot;/&quot;;</div><div class="line">        if(this.router[url])&#123;</div><div class="line">            this.router[url]();</div><div class="line">        &#125;else&#123;</div><div class="line">            throw new Error(&quot;It&apos;s not register router&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    route(path,cb)&#123;</div><div class="line">        this.router[path] = cb || function () &#123;</div><div class="line">        	throw new Error(&quot;please give a callback&quot;);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    init()&#123;</div><div class="line">        let _this = this;</div><div class="line">        window.addEventListener(&quot;popstate&quot;,function (event) &#123;</div><div class="line">        	this.refresh(event.state || &#123;&#125;);</div><div class="line">        &#125;.bind(this))</div><div class="line">        </div><div class="line">        document.querySelectorAll(&quot;a&quot;).forEach(a =&gt; &#123;</div><div class="line">            a.addEventListener(&quot;click&quot;,function (e) &#123;</div><div class="line">                e.preventDefault();</div><div class="line">                </div><div class="line">                let path = link.slice(1) || &quot;/&quot;;</div><div class="line">                let link = a.getAttribute(&quot;href&quot;);</div><div class="line">                _this.refresh(&#123;path : path&#125; || &#123;&#125;);</div><div class="line">                if(e.target.getAttribute(&quot;type&quot;) === &apos;replace&apos;)&#123;</div><div class="line">                    window.history.replaceState(&#123;&apos;path&apos;:path&#125;,path,e.target.hre;</div><div class="line">                &#125; else &#123;</div><div class="line">                    window.history.pushState(&#123;&apos;path&apos; : path&#125;,path,e.target.href);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;,false);</div><div class="line">        </div><div class="line">        //首次进入路由</div><div class="line">        let path = window.location.hash.slice(1) || &apos;/&apos;;</div><div class="line">        this.refresh(&#123;path : path&#125; || &#123;&#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">function changeContent(text)&#123;</div><div class="line">        document.getElementById(&apos;content&apos;).innerHTML = text;</div><div class="line">&#125;</div><div class="line">    </div><div class="line">let router = new Router(&#123;</div><div class="line">    &apos;/&apos;()&#123;</div><div class="line">        changeContent(&quot;home&quot;);</div><div class="line">    &#125;,</div><div class="line">    &apos;/router1&apos;()&#123;</div><div class="line">        changeContent(&quot;router1&quot;);</div><div class="line">    &#125;,</div><div class="line">    &apos;/router2&apos;()&#123;</div><div class="line">        changeContent(&quot;router2&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line">    </div><div class="line">    router.route(&apos;/router3&apos;,function()&#123;</div><div class="line">    changeContent(&apos;路由3&apos;);</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/我的圣诞老人/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/我的圣诞老人/" itemprop="url">我的圣诞老人</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T23:47:44+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/12/25/我的圣诞老人/" class="leancloud_visitors" data-flag-title="我的圣诞老人">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  769
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我不知道大家是什么时候知道圣诞节的，也不知道很多人会不会有和我一样的童年经历。</p>
<p>在我很小很小的时候，也许是幼儿园，也许是学前班，也许是记忆开始的时候，不知道从哪里听到了圣诞老人的传说。只要将一只空袜子放在床头，圣诞老人会在袜子里放上你最想要的礼物。</p>
<p>不知道刚听到这个传说的时候，自己是怎么样的心情，喜悦？迷惑？还是好奇。只记得自己小心翼翼的挑了一只最大的袜子，抚平了放在头边，然后带着期待的心情进入了梦乡。</p>
<p>现在已经想不起来自己第一次收到了什么礼物，一盒水彩笔？还是什么？</p>
<p>但还能回忆出醒来之后睁大眼睛找袜子的我，拿着礼物在床上蹦蹦跳跳的我，告诉爸妈圣诞老人来了，最后拿起礼物飞奔出去炫耀的我。你知道吗，圣诞老人来我家送礼物啦！</p>
<p>之后几年，自己依然和以前一样准备好了空袜子，也开始好奇圣诞老人到底是什么样子。只知道电视里的他是一个穿着红衣服，有的白胡子的老爷爷，他会从家里的烟囱爬进来，然后从大麻袋中挑出你最想要的礼物。</p>
<p>于是我不断在那一晚提醒着自己，不要睡着，要一直守着，要亲眼看看圣诞老人是什么样子的。可是孩子的好奇终究抵不过睡意，虽然第二天仍然收到了礼物，但还是没有看到老爷爷的样子。</p>
<p>只不过对孩子而言，只要有礼物就好了，圣诞老人到底是什么模样，他是不是从烟囱爬进来又有什么关系呢。</p>
<p>后来，直到有一年我再也没有在袜子边上看见礼物的时候，哭闹着打爸妈的时候，圣诞老人的故事在我身上就结束了。</p>
<p>懂事以后，自然知道了圣诞老人是假的。只是真的感谢我的圣诞老人，在我的童年里满足了一个爱幻想的小孩子，当别的小孩在说“圣诞老人就是你妈妈的时候”，“世界上没有圣诞老人”时，我仍然可以一口坚定，“世界上有圣诞老人”，“看，这就是圣诞老人给我的礼物”。<br>感谢我的圣诞老人。</p>
<p>不知道为什么今晚会想写这一些的文字，只是真的很感谢我的爸爸妈妈。因为你们，帮助我在这个城市生活的远比很多人轻松，也是今年经历了太多的事情，我才明白，你们给我的帮助，远比我想象的还要更多。也许我永远无法当面说出“我爱你们”这些话，可是我会努力不让你们失望。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/23/《算法图解》读后感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/23/《算法图解》读后感/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-23T16:49:24+08:00">
                2017-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/11/23/《算法图解》读后感/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  351
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>算法算法，一个这两年被人念叨最多的词汇，但很多时候身为一个前端人员完全感受不到其所在，所以一直对此也很是懵逼。这段时间也是无聊，于是看了一本算法图解的书，还是很能感受到其中的一些魅力所在的额</p>
</blockquote>
<h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>二分查找算法,是本书的第一个算法，用于有序数据的快速查找。</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>链表相对于数组的优势</p>
<ul>
<li>当插入数据较多而读取数据较少时，</li>
</ul>
<table>
<thead>
<tr>
<th>1</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>O(n),需要从第一个开始查找到最后一个才能插入</td>
<td>O(1)随便扔一个地方</td>
</tr>
<tr>
<td>读取</td>
<td>O(1)直接知道数据位置在哪里</td>
<td>O(n)需要知道前面的才能知道后面的</td>
</tr>
<tr>
<td>删除</td>
<td>O(n)遍历所有的一个个开始删除</td>
<td>O(1)直接修改每个项所代表的索引</td>
</tr>
</tbody>
</table>
<h4 id="三-快速查找排序算法"><a href="#三-快速查找排序算法" class="headerlink" title="三 快速查找排序算法"></a>三 快速查找排序算法</h4><p>快速查找排序算法：最常见的排序算法，举例描述：先找出一个数组中最小的，推出到新数组中，然后来n次遍历，得出由小到大的新数组。时间复杂度为O(n2);</p>
<h4 id="四递归调用"><a href="#四递归调用" class="headerlink" title="四递归调用"></a>四递归调用</h4><p>主要讲解了基本的栈和递归调用，最后讲到的高级递归主题尾递归需要看一下</p>
<h4 id="五"><a href="#五" class="headerlink" title="五"></a>五</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/19/《JavaScript 正则表达式迷你书》读后感/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/19/《JavaScript 正则表达式迷你书》读后感/" itemprop="url">js中数组的原生方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-19T13:47:44+08:00">
                2017-11-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/11/19/《JavaScript 正则表达式迷你书》读后感/" class="leancloud_visitors" data-flag-title="js中数组的原生方法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  2,417
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>国庆时间看到作者出版了一本正则表达式的书，因为之前一直对模板好奇，于是就去作者的网盘里面下载了这一本书的pdf版观看。最近看完之后觉得作者写的很棒，弥补了自己很多正则的基础 知识。附上链接<a href="https://zhuanlan.zhihu.com/p/29707385?utm_source=com.daimajia.gold&amp;utm_medium=social" target="_blank" rel="external">《JavaScript 正则表达式迷你书》问世了！</a>。</p>
<p>文章主要记录了一下自己的学习心得</p>
<h4 id="1-复杂的正则表达式可以由几个简单的正则表达式组合而成"><a href="#1-复杂的正则表达式可以由几个简单的正则表达式组合而成" class="headerlink" title="1. 复杂的正则表达式可以由几个简单的正则表达式组合而成"></a>1. 复杂的正则表达式可以由几个简单的正则表达式组合而成</h4><p>记得之前每次写密码验证的时候，总希望一个正则表达式搞定全部的情况，看完书后觉得原来没有必要。</p>
<p>以密码验证为例出题：<br><strong>密码长度 6-12 位，由数字、小写字符和大写字母组成，但必须至少包括 2 种字符</strong>。大家可以想一下怎么实现。</p>
<p>书中一开始得出了一个非常复杂的正则表达式,但是其实后期维护修改未必简单，而且换一个同事来维护，刚开始理解也很辛苦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!--复杂版正则表达式--&gt;</div><div class="line">let regex = /(?!^[0-9]&#123;6,12&#125;$)(?!^[a-z]&#123;6,12&#125;$)(?!^[A-Z]&#123;6,12&#125;$)^[0-9A-Za-z]&#123;6,12&#125;$/;</div><div class="line"></div><div class="line">&lt;!--简单易懂版正则表达式--&gt;</div><div class="line">let regex1 = /^[0-9A-Za-z]&#123;6,12&#125;$/; //6-12位的数字、小写字符和大写字母组成</div><div class="line">let regex2 = /^[0-9]&#123;6,12&#125;$/;   //不包含数字（就是只包含大小写字母）</div><div class="line">let regex3 = /^[A-Z]&#123;6,12&#125;$/;   //不包含大写字母（就是只包含数字和小写）</div><div class="line">let regex4 = /^[a-z]&#123;6,12&#125;$/;   //不包含小写字母（就是只包含数字和大写）</div><div class="line">function checkPassword (string) &#123;</div><div class="line">    if (!regex1.test(string)) return false;</div><div class="line">    if (regex2.test(string)) return false;</div><div class="line">    if (regex3.test(string)) return false;</div><div class="line">    if (regex4.test(string)) return false;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，第一种对于我这种刚开始实战不多的，颇有一点炫技的表现（也有可能是我太菜）。第二种一看，会舒服很多，高可读性和高可维护性。</p>
<p>我个人认为在团队合作中，第二种对于后期伙伴的维护应该是更佳的。</p>
<hr>
<h4 id="2-的各个含义"><a href="#2-的各个含义" class="headerlink" title="2. ?的各个含义"></a>2. ?的各个含义</h4><p>在看书的时候，因为之前正则的基础很薄弱，看见书中频频出现的？用在不同地方实现不一样的效果，我是一脸懵逼，经常要上百度看一下？用在这里表示什么意思。这里小总结一下</p>
<h5 id="2-1-本身符号“？”"><a href="#2-1-本身符号“？”" class="headerlink" title="2.1 本身符号“？”"></a>2.1 本身符号“？”</h5><p>表达自身一个“？”字符，但是因为？在正则表达式中的作用太多了，所以当它需要表达自身的时候，需要进行一次转义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\?</div></pre></td></tr></table></figure></p>
<h5 id="2-2-表示匹配次数"><a href="#2-2-表示匹配次数" class="headerlink" title="2.2 表示匹配次数,"></a>2.2 表示匹配次数,</h5><p>这是常见的第一种用法，允许重复匹配的次数，0次或者1次。</p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let regex1 = /\d*/;</div><div class="line">let str = &quot;12345&quot;;</div><div class="line">str.match(regex);   //[&quot;12345&quot;, index: 0, input: &quot;12345&quot;]</div><div class="line"></div><div class="line"></div><div class="line">//======使用了？号======//</div><div class="line">let regex = /\d?/;  //最大允许匹配一次数字</div><div class="line">let str = &quot;12345&quot;;</div><div class="line">str.match(regex);   //[&quot;1&quot;, index: 0, input: &quot;1234&quot;]</div></pre></td></tr></table></figure></p>
<h5 id="2-3-表示懒惰匹配"><a href="#2-3-表示懒惰匹配" class="headerlink" title="2.3 表示懒惰匹配"></a>2.3 表示懒惰匹配</h5><p>这是常见的第二种用法，因为正则表达式默认是贪婪匹配的，所以很多时候我们会在某组匹配字符后加一个问号表示非贪婪匹配    </p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let regex = /\d&#123;1,3&#125;/</div><div class="line">let str = &quot;12345&quot;;</div><div class="line">str.match(regex);   //[&quot;123&quot;, index: 0, input: &quot;12345&quot;]</div><div class="line"></div><div class="line"></div><div class="line">//======添加了？号======//</div><div class="line">let regex = /\d&#123;1,3&#125;?/</div><div class="line">let str = &quot;12345&quot;;</div><div class="line">str.match(regex);   //[&quot;1&quot;, index: 0, input: &quot;1234&quot;]</div></pre></td></tr></table></figure></p>
<h5 id="2-4-配合字符实现位置匹配"><a href="#2-4-配合字符实现位置匹配" class="headerlink" title="2.4 配合字符实现位置匹配"></a>2.4 配合字符实现位置匹配</h5><p>书中讲到了 这么一句话</p>
<blockquote>
<p>正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。</p>
<p>关于”位置”这个概念的理解推荐看书中的第二章</p>
</blockquote>
<p>而当你匹配位置的时候，两个匹配位置的正则表达式就非常关键了。</p>
<p>(?=p)，其中 p 是一个子模式，即 p 前面的位置，或者说，该位置后面的字符要匹配 p。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let result = &quot;hello&quot;.replace(/(?=l)/g, &apos;#&apos;);</div><div class="line">console.log(result);    // &quot;he#l#lo&quot;</div></pre></td></tr></table></figure></p>
<p>而 (?!p) 就是 (?=p) 相反的意思，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let result = &quot;hello&quot;.replace(/(?!l)/g, &apos;#&apos;);</div><div class="line">console.log(result);    // &quot;#h#ell#o#&quot;</div></pre></td></tr></table></figure></p>
<p>这两个用法在数字格式化的时候有非常大的用处。给大家出个题目吧，<strong>如何实现数字的千位分隔符表示</strong>。比如讲1234567转化为12,345,678。</p>
<p>大家思考一下</p>
<p>….</p>
<p>….</p>
<p>….</p>
<p><strong>答案</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let regex = /(?!^)(?=(\d&#123;3&#125;)+$)/g;</div><div class="line">&quot;12345678&quot;.replace(regex1,&quot;,&quot;); // &quot;12,345,678&quot;</div></pre></td></tr></table></figure></p>
<p>具体实现看不懂还是推荐去看原书，作者写的很好，我相信对大家帮助肯定也很大。</p>
<h5 id="2-5-非捕获模式"><a href="#2-5-非捕获模式" class="headerlink" title="2.5 非捕获模式"></a>2.5 非捕获模式</h5><p>还有最后一种不怎么常见（可能是没怎么见过）的用法(?:),表示非捕获模式。我是这么理解的（不知道自己理解的对不对），就是当你遇到匹配的字符时，它并没有马上捕获匹配的内容，并且记录下拉，而是继续匹配下去作为为整体匹配服务。讲的不好，大家还是看例子实在吧（手动捂脸）。</p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let regex = /(?:a)(b)(c)/; &quot;abcabc&quot;.match(regex)</div><div class="line">//结果 [&quot;abc&quot;, &quot;b&quot;, &quot;c&quot;]</div><div class="line">// m[0] 是/(?:a)(b)(c)/匹配到的整个字符串，这里包括了a</div><div class="line">// m[1] 是捕获组1，即(b)匹配的子字符串substring or sub sequence</div><div class="line">// m[2] 是捕获组2，即(c)匹配到的</div></pre></td></tr></table></figure></p>
<p>大家可以注意到第一个括号里面的<strong>a</strong>并没有被提取出来，但是整体匹配的字符时有<strong>a</strong>的。这就是我理解的非捕获模式，为整体存在的匹配。</p>
<hr>
<h4 id="3-回溯的学习"><a href="#3-回溯的学习" class="headerlink" title="3. 回溯的学习"></a>3. 回溯的学习</h4><p>性能和效率始终是绕不开的一环，文中提到回溯造成原因我感觉主要是由2点造成的，</p>
<ul>
<li>一是由于匹配默认是贪婪的</li>
<li>二是由于匹配有时候是懒惰的。(使用分支情况下)</li>
</ul>
<h5 id="3-1-贪婪匹配造成的回溯"><a href="#3-1-贪婪匹配造成的回溯" class="headerlink" title="3.1 贪婪匹配造成的回溯"></a>3.1 贪婪匹配造成的回溯</h5><p>先说第一种情况，贪婪匹配造成的回溯，举个书中的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;&quot;abc&quot;de&apos;;</div><div class="line">let regex = /&quot;.*&quot;/;</div><div class="line">str.match(regex);   //  [&apos;&quot;abc&quot;&apos;, index: 0, input: &apos;&quot;abc&quot;de&apos;]</div></pre></td></tr></table></figure></p>
<p>当用此正则表达式去匹配字符串的时候，发现最后无法完成整体匹配的时候，会不断回吐一个字符再次去尝试整体正确的匹配。大家可以结合下图理解。<br><img src="https://raw.githubusercontent.com/linzx1993/linzx1993.github.io/master/images/regex-1.png" alt="image"></p>
<p>书中最后讲到回溯是<strong>非常影响效率</strong>的，但是自己在写例子测试的时候，发现其实时间基本上没有任何差别，不知道是不是因为自己测试的正则比较简单，还是浏览器现在对于正则的优化做的比较好，总之没有达到书中说的到<strong>非常影响效率</strong>的程度。</p>
<p><strong>效率对比例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">    let str = &apos;&quot;abc&quot;dddddddddddddddddddddddddddddde&apos;;</div><div class="line">    let regex = /&quot;.*&quot;/;</div><div class="line">&#125;;</div><div class="line">console.time()</div><div class="line">for(var i = 0;i&lt; 1000000000;i++)&#123;test()&#125;</div><div class="line">console.timeEnd()</div><div class="line">//default: 2321.663818359375ms</div><div class="line"></div><div class="line">//========修改为减少贪婪回溯的写法========//</div><div class="line">function test()&#123;</div><div class="line">    let str = &apos;&quot;abc&quot;dddddddddddddddddddddddddddddde&apos;;</div><div class="line">    let regex = /&quot;[^&quot;]]*&quot;/;</div><div class="line">&#125;;</div><div class="line">console.time()</div><div class="line">for(var i = 0;i&lt; 1000000000;i++)&#123;test()&#125;</div><div class="line">console.timeEnd()</div><div class="line"></div><div class="line">//default: 2327.2890625ms</div></pre></td></tr></table></figure></p>
<p>对于这种回溯的解决方法来说：</p>
<ul>
<li>方法1 ：写尽量正确的匹配。像上面例子中的修改版就是这种解决方法，</li>
<li>方法2 ：尽可能少的匹配。比如加个惰性量词“？”。(其实就是尽量减少贪婪匹配)</li>
</ul>
<h5 id="3-2懒惰匹配造成的回溯"><a href="#3-2懒惰匹配造成的回溯" class="headerlink" title="3.2懒惰匹配造成的回溯"></a>3.2懒惰匹配造成的回溯</h5><p>然而并不是所有回溯的情况都是由贪婪造成的。比如当我们在使用分支匹配的时候。 </p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;candy&apos;;</div><div class="line">let regex =/can|candy/;</div><div class="line">str.match(regex);   //[&quot;can&quot;, index: 0, input: &quot;candy&quot;]</div></pre></td></tr></table></figure></p>
<p>当我们用/can|candy/去匹配字符串 “candy”，得到的结果是 “can”，因为分支会<br>一个一个尝试，如果前面的满足了，后面就不会再试验了。但是如果我们的目标字符串是“candy”的时候，那怎么办呢。</p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;candy&apos;;</div><div class="line">let regex = /^(?:can|candy)$/;</div><div class="line">str.match(regex);   //[&quot;candy&quot;, index: 0, input: &quot;candy&quot;]</div></pre></td></tr></table></figure></p>
<p>大家可以先看图理解一下懒惰造成的回溯<br><img src="https://raw.githubusercontent.com/linzx1993/linzx1993.github.io/master/images/regex-2.png" alt="image"></p>
<hr>
<h4 id="4-跟正则有关几个正则方法"><a href="#4-跟正则有关几个正则方法" class="headerlink" title="4. 跟正则有关几个正则方法"></a>4. 跟正则有关几个正则方法</h4><p>字符串对象和正则对象提供了很多跟正则有关的基础方法，很多方法都都有很好的使用场景。</p>
<h5 id="4-1-RegExp-test"><a href="#4-1-RegExp-test" class="headerlink" title="4.1 RegExp#test"></a>4.1 RegExp#test</h5><p>比如我在表单验证的场景里，用户每次输入值我需要进行判断用户是否输入正确，我可是使用regex.test()方法来确定是否给用户提示</p>
<p><strong>只允许输入数字</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;input onkeyup=&quot;test(this.value)&quot; /&gt;</div><div class="line"></div><div class="line">function test(value)&#123;</div><div class="line">    let regex = /[^\d]/g;</div><div class="line">	if(regex.test(value))console.log(&quot;请输入数字&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="4-2-String-replace"><a href="#4-2-String-replace" class="headerlink" title="4.2 String#replace"></a>4.2 String#replace</h5><p>这个replace方法用处实在是太大了，已经到了可以单开一篇的地步了，大家可以前往这里去看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace" target="_blank" rel="external">MDN上replace的文档</a>，这里就不详细介绍了。这里写个简单的例子</p>
<p><strong>最简单的模板编译</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let str = &apos;我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;&apos;;</div><div class="line">let obj = &#123;</div><div class="line">		name:&apos;姓名&apos;,</div><div class="line">		age:18,</div><div class="line">		sex: &apos;男&apos;</div><div class="line">	&#125;</div><div class="line">let strEnd = str.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,function (match, m1) &#123;</div><div class="line">	return obj(m1)</div><div class="line">&#125;)</div><div class="line">//  &quot;我是姓名，年龄18，性别undefined&quot;</div></pre></td></tr></table></figure></p>
<h5 id="4-3-String-search"><a href="#4-3-String-search" class="headerlink" title="4.3 String#search"></a>4.3 String#search</h5><p>这个方法感觉和indexOf效率有一些相似，都是寻找符合匹配的下标。不过indexOf方法是为字符串使用的，而search是为正则表达式实现的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let str = &apos;abc123456&apos;;</div><div class="line">let regex = /\d/;</div><div class="line">console.log(str.search(regex)); // 3</div></pre></td></tr></table></figure></p>
<h5 id="4-3-String-split"><a href="#4-3-String-split" class="headerlink" title="4.3 String#split"></a>4.3 String#split</h5><p>字符串的split方法同样支持正则表达式进行切割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var regex = /,/;</div><div class="line">var string = &quot;html,css,javascript&quot;;</div><div class="line">console.log( string.split(regex) );</div></pre></td></tr></table></figure></p>
<h5 id="4-4-String-match"><a href="#4-4-String-match" class="headerlink" title="4.4 String#match"></a>4.4 String#match</h5><p>这个方法更多是为了提取匹配内容而存在的。当你的正则表达式里面有小括号（）的存在时，match方法可以帮你提取出字符串中符合括号正则的表达式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var regex = /^(\d&#123;4&#125;)\D(\d&#123;2&#125;)\D(\d&#123;2&#125;)$/;</div><div class="line">var string = &quot;2017-06-26&quot;;</div><div class="line">console.log( string.match(regex) );</div><div class="line">// [&quot;2017-06-26&quot;, &quot;2017&quot;, &quot;06&quot;, &quot;26&quot;, index: 0, input: &quot;2017-06-26&quot;]</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/手写Vue组件踩坑与心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/手写Vue组件踩坑与心得/" itemprop="url">js中数组的原生方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T13:47:44+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/10/29/手写Vue组件踩坑与心得/" class="leancloud_visitors" data-flag-title="js中数组的原生方法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,807
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>记得以前看过一句话，说市面上任何的UI库都无法满足一个产品的所有需求。</p>
</blockquote>
<p>事实上的确如此，产品需求总是千奇百怪。正如我公司现在的产品，引用的是elemen-ui的库，但是无法级联多选，下拉多选的展现形式不对，穿梭框无法上下移动等各种需求逼迫我们只能自己去写组件实现了。</p>
<p>自己手写实现了两个组件之后，先写一篇记录一些坑和学会的新东西</p>
<h4 id="1、子组件不允许修改父组件数据"><a href="#1、子组件不允许修改父组件数据" class="headerlink" title="1、子组件不允许修改父组件数据"></a>1、子组件不允许修改父组件数据</h4><p>之前在写angular的父子组件传递数据，子组件可以修改父组件传递进来的数据。不过在Vue中子组件不允许修改父组件穿进来的值，以vue举例来说<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;!--父组件HTML内容--&gt;</div><div class="line">&lt;children-component :value=&quot;data&quot;&gt;&lt;/children-component&gt;</div><div class="line"></div><div class="line">&lt;!--父组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    data()&#123;</div><div class="line">        return &#123;</div><div class="line">            data : [1,2,3,4]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!--子组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    props : [&quot;value&quot;],</div><div class="line">    created : &#123;</div><div class="line">        this.value = [5,6,7,8];</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>此举会引发一个非常常见的报错，<br><img src="https://raw.githubusercontent.com/linzx1993/linzx1993.github.io/master/images/error1.png" alt="image"></p>
<p>那么解决方法是什么呢，那就要看你需求了。比如传进来的是一个渲染列表，我需要的只是修改渲染的数据，那么可以emit出去，然后在父组件重新赋值，通过双向绑定，触发子组件的再次渲染。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&lt;!--父组件HTML内容--&gt;</div><div class="line">&lt;children-component :value=&quot;data&quot; @changeProp=&quot;changeData&quot;&gt;&lt;/children-component&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;!--父组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    data()&#123;</div><div class="line">        return &#123;</div><div class="line">            data : [1,2,3,4]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    methods : &#123;</div><div class="line">        changeData(value)&#123;</div><div class="line">            this.data = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!--子组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    props : [&quot;value&quot;],</div><div class="line">    created : &#123;</div><div class="line">        this.$emit(&quot;changeProp&quot;,[5,6,7,8])</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>例子写的比较简单，其实原理就是emit一个数据到父组件上去，然后在父组件中接受到这个传递上来的新值，将data赋予新值，然后重新传递到了子组件，起到一个变向修改子组件的效果。</p>
<hr>
<p>被人提醒到一个方法是用.sync，这个方法也是可以的。之前一直以为是被废弃就没用，才发现它其实是在的。看了一下<a href="https://cn.vuejs.org/v2/guide/components.html#sync-修饰符" target="_blank" rel="external">.synv文档</a>，发现这其实是一个语法糖的形式展现出来。如文档所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;!--日常使用语法糖形态--&gt;</div><div class="line">&lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt;</div><div class="line">&lt;!--↓↓↓↓↓真实形态↓↓↓↓↓↓--&gt;</div><div class="line">&lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;</div><div class="line">&lt;!--子组件js代码--&gt;</div><div class="line">this.$emit(&apos;update:foo&apos;, newValue)</div></pre></td></tr></table></figure></p>
<p>个人感觉Vue框架其实还是不赞同直接修改数据，但是它帮你定义了一个update事件，让你在子组件可以直接显式调用，不需要自己去定义事件这么麻烦了。大家还是把自定义事件用在一些事件上吧。</p>
<h4 id="2-Vue给每个组件提供了一个默认的父子传递事件v-model。"><a href="#2-Vue给每个组件提供了一个默认的父子传递事件v-model。" class="headerlink" title="2.Vue给每个组件提供了一个默认的父子传递事件v-model。"></a>2.Vue给每个组件提供了一个默认的父子传递事件v-model。</h4><p>但是你每次父子组件传递数据时，都要父子处定义一个事件是很麻烦的，vue则为每个组件提供了一个默认v-model的语法糖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&lt;!--父组件HTML内容--&gt;</div><div class="line">&lt;children-component v-mode=&quot;data&quot; &gt;&lt;/children-component&gt;</div><div class="line"></div><div class="line">&lt;!--父组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    data()&#123;</div><div class="line">        return &#123;</div><div class="line">            data : [1,2,3,4]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    watch : &#123;</div><div class="line">        //可以在此处监听子组件传递上来的数据</div><div class="line">        data(n,o)&#123;</div><div class="line">            console.log(n,o);   //[5,6,7,8],[1,2,3,4]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!--子组件的js内容--&gt;</div><div class="line"></div><div class="line">export default(&#123;</div><div class="line">    &lt;!--大家注意我下面这行代码是打了注释的，说明我在子组件没有定义任何属性--&gt;</div><div class="line">    //  props : [&quot;value&quot;]</div><div class="line">    &lt;!--并且我接下去直接在代码中使用了this.value(一个完全没有定义过的value)。--&gt;</div><div class="line">    created : &#123;</div><div class="line">        console.log(this.value);</div><div class="line">        this.$emit(&quot;input&quot;,[5,6,7,8]);  //当我想改变传进来值的时候</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>因为之前一直使用ng-model来用于表单组件的传递，所以开始对于v-mode也是这个印象，不过后面看了element-ui的源码才发现我想简单了，然后网上搜了一下对于这个语法糖的解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//注意，该组件不是表单组件</div><div class="line">&lt;children-component :value=&quot;data&quot; @input=&quot;data = arguments[0]&quot;&gt;&lt;/children-component&gt;</div></pre></td></tr></table></figure></p>
<p>看了这行代码大家心里估计也能明白的差不多了，其实Vue只是帮我们把父组件上的两段声明合二为一了，同时再帮我们在子组件处直接省略了定义。语法糖说到底就是帮我们省力的嘛。</p>
<h4 id="3-部分属性名的选择"><a href="#3-部分属性名的选择" class="headerlink" title="3.部分属性名的选择"></a>3.部分属性名的选择</h4><p>因为在父子组件传递数据的时候，我们会通过在父组件写属性名将属性传递进去，理论上你可以写任何一个属性名<strong>a</strong>,<strong>value</strong>,<strong>list</strong>,<strong>data</strong>，但是有几个关键字已经被Vue内部保留了,比如下面的<strong>key</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;children-component :key=&quot;data&quot; :value=&quot;list&quot;&gt;&lt;/children-component&gt;</div><div class="line"></div><div class="line">&lt;!--父组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    data()&#123;</div><div class="line">        return &#123;</div><div class="line">            data : [1,2,3,4],</div><div class="line">            list : [1,2,4,5]</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!--子组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    //  props : [&quot;value&quot;,&quot;key&quot;]</div><div class="line">    created : &#123;</div><div class="line">        console.log(this.value);</div><div class="line">        console.log(this.key);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/linzx1993/linzx1993.github.io/master/images/vue-key.png" alt="image"><br>当然如果我不在props里面写入key这个属性的话，是不会报错的。</p>
<p>然后想起项目中在写下拉框组件时，如果你对自己以前写的option组件进行repeat的时候，key会作为一个关键字进行标记，不传key的话，vue会给出黄色提醒，不是报错，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;demo-select :optionList=&quot;optionList&quot;&gt;</div><div class="line">    &lt;demo-option v-for=&quot;option in optionList&quot; :key=&quot;option.value&quot; :value=&quot;option.value&quot;&gt;&#123;&#123;option.label&#125;&#125;&lt;/demo-option&gt;</div><div class="line">&lt;/demo-select&gt;</div><div class="line">&lt;!--父组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    data()&#123;</div><div class="line">        return &#123;</div><div class="line">            optionList : [&#123;label:1,value:1&#125;,&#123;label:2,value:2&#125;,&#123;label:3,value:3&#125;],</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">&#125;)</div><div class="line"></div><div class="line">&lt;!--子组件的js内容--&gt;</div><div class="line">export default(&#123;</div><div class="line">    //  props : [&quot;value&quot;,&quot;key&quot;]</div><div class="line">    created : &#123;</div><div class="line">        console.log(this.value);</div><div class="line">        console.log(this.key);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><img src="https://raw.githubusercontent.com/linzx1993/linzx1993.github.io/master/images/vue-key-info.png" alt="image"><br>如果我在对需要repeat的子组件中没有添加:key这个属性的话，则会给出上面的提醒。原因呢，<a href="https://cn.vuejs.org/v2/guide/list.html#key" target="_blank" rel="external">文档里面也有述说</a>,作为一个唯一标识的id，为了对比VNode而存在，不过这是另一个话题了。</p>
<p>好了回到开头，总结性话语就是不要写key传递属性。不过不知道还有没有什么其他的属性</p>
<h4 id="4-全局一次性引用写好的组件"><a href="#4-全局一次性引用写好的组件" class="headerlink" title="4.全局一次性引用写好的组件"></a>4.全局一次性引用写好的组件</h4><p>假如我们写好了一些组件，接下去肯定还要引入和使用吧。但是你写了这么多组件，在每个地方一个个引用想要的是一件很麻烦的事情。我们最好是在一个初始的地方一次性全部引入，然后在用的地方直接使用</p>
<blockquote>
<p>(当然全部引入无可避免的会引入和打包不需要的东西，不过这是公共组件库的烦恼，我们自己写的肯定会全部用到)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 在文件开头初始引入所有的组件文件</div><div class="line">import b from &quot;./components/common/b.vue&quot;</div><div class="line">import c from &quot;./components/common/c.vue&quot;</div><div class="line"></div><div class="line">const components = [b,c];</div><div class="line"></div><div class="line">const install = function (Vue, opts = &#123;&#125;) &#123;</div><div class="line">	components.map(component =&gt; &#123;</div><div class="line">		Vue.component(component.name, component);</div><div class="line">	&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">export default install</div></pre></td></tr></table></figure></p>
</blockquote>
<p>然后直接在启动的main.js文件里面引入就好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import ui from &quot;install.js&quot;</div><div class="line">Vue.use(ui);</div></pre></td></tr></table></figure></p>
<p>然后你就可以随意在任何一个组件里面直接调用了，比自己之前在每个组件里重复调用要方便一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;b v-model=&quot;data1&quot;&gt;&lt;/b&gt;</div><div class="line">&lt;c v-model=&quot;data2&quot;&gt;&lt;/c&gt;</div></pre></td></tr></table></figure></p>
<h4 id="4-为组件属性添加默认"><a href="#4-为组件属性添加默认" class="headerlink" title="4.为组件属性添加默认"></a>4.为组件属性添加默认</h4><p>好了，暂时到这里，都是自己的踩得坑和心得，希望对大家有所帮助吧，接下去还有的话再补充好了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/js模板内容/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/11/js模板内容/" itemprop="url">未命名</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T09:08:21+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/10/11/js模板内容/" class="leancloud_visitors" data-flag-title="">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  782
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文章主要是自己用于熟悉正则的几个方法，并没有如何写正则表达式的内容，如果希望学习写正则匹配的，我也不太会(手动捂脸)</p>
</blockquote>
<p>首先让我们先熟悉一个最常见的API——replace()方法</p>
<blockquote>
<p>replace不会修改原字符串</p>
</blockquote>
<p><strong>语法和参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">str.replace(regexp|substr, newSubStr|function)</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>regexp</td>
<td>一个RegExp 对象或者字符串。该正则所匹配的内容会被第二个参数的返回值替换掉。</td>
</tr>
<tr>
<td>substr</td>
<td>一个要被 newSubStr 替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。</td>
</tr>
<tr>
<td>newSubStr</td>
<td>用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。</td>
</tr>
<tr>
<td>function</td>
<td>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。</td>
</tr>
</tbody>
</table>
<p><strong>先看一个最简单的例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = &quot;abcd1234&quot;.replace(&quot;1234&quot;,&quot;e&quot;); //将字符串&quot;1234&quot;替换为字符&quot;e&quot;</div><div class="line">let b = &quot;1234abcd1234&quot;.replace(/\d+/g,&quot;e&quot;); //将数字替换为字符&quot;e&quot;</div><div class="line">console.log(a); //abcde ,用字符串匹配没想到怎么全局替换，知道的可以告诉一下</div><div class="line">console.log(b); //eabcde</div></pre></td></tr></table></figure></p>
<p>但是很多时候纯粹的替换字符的场景比较少，很多时候我们希望将获得到的值经过操作然后替换上去，所以replace()方法也很聪明的提供了回调函数。接下来我们来熟悉下回调函数的参数</p>
<p><strong>先看语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str.replace(regexp, function(match,p1,offset,string)&#123;&#125;)</div></pre></td></tr></table></figure></p>
<p><strong>再看参数含义</strong></p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>match</td>
<td>匹配的子串，即字符串中那一些符合匹配规则的子字符串（可以理解成“abcd”中的是“bc”）</td>
</tr>
<tr>
<td>p1</td>
<td>第一个匹配到的内容</td>
</tr>
<tr>
<td>offset</td>
<td>匹配到的子字符串在原字符串中索引。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）</td>
</tr>
<tr>
<td>string</td>
<td>被匹配的原字符串。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其实如果大家之前有用过match这个API的话，就能发现他的形参全部是以match为基础进行实现的</p>
</blockquote>
<p>这个时候再来一个<strong>简单版的小demo</strong>对着看，大家基本上就能明白了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;strss&quot;.replace(/s+/g, function(match,offset,string)&#123;</div><div class="line">    console.log(match)</div><div class="line">    console.log(offset)</div><div class="line">    console.log(string)</div><div class="line">&#125;);</div><div class="line">//  s</div><div class="line">//  0</div><div class="line">//  strss</div><div class="line">//  ss</div><div class="line">//  3</div><div class="line">//  strss</div></pre></td></tr></table></figure></p>
<blockquote>
<p>有没有一种ES5数组回调参数的既视感</p>
</blockquote>
<p>不过回调函数提供的参数还赋予了更强大的功能，这里我们先暂时略过</p>
<p>发现还是避不过正则表达式匹配的内容</p>
<p>我们可以先在熟悉语法的情况下，一步一步从最基本的方法使用来认识这个方法</p>
<p>因为我们想在最终的替换中进一步转变匹配结果，所以我们必须使用一个函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/Javascripts数组原生方法集合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/Javascripts数组原生方法集合/" itemprop="url">js中数组的原生方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-03T23:47:44+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/03/Javascripts数组原生方法集合/" class="leancloud_visitors" data-flag-title="js中数组的原生方法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  7,515
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  30
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>数组应该是我们在写程序中应用到最多的数据结构了，相比于无序的对象，有序的数组帮我们在处理数据时，实在是帮了太多的忙了。今天刚好看到一篇Array.include的文章，忽然发现经过几个ES3,ES5,ES6,ES7几个版本的更迭，发现在代码中用到了好多数组的方法，所以准备全部列出来，也是给自己加深印象</p>
</blockquote>
<h2 id="1-ES3中的数组方法"><a href="#1-ES3中的数组方法" class="headerlink" title="1 ES3中的数组方法"></a>1 ES3中的数组方法</h2><ul>
<li>ES3兼容现在所有主流浏览器</li>
</ul>
<p>ES3中的方法毫无疑问大家已经烂熟在心了，不过中间有些细节可以回顾加深一下记忆，比如是否修改原数组返回新数组，执行方法之后的返回值是什么，某些参数的意义是否搞混等等。熟悉的的可以直接快速浏览或者跳过。</p>
<h3 id="1-1-join-方法"><a href="#1-1-join-方法" class="headerlink" title="1.1 join()方法"></a>1.1 join()方法</h3><p>Array.join()方法是将一个数组里面的所有元素转换成字符串，然后再将他们连接起来<strong>返回一个新数组</strong>。可以传入一个可选的字符串来分隔结果字符串中的所有元素。如果没有指定分隔字符串，就默认使用逗号分隔。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a  = [1,2,3,4,5,6,7];</div><div class="line">let b = a.join();    // b = &quot;1,2,3,4,5,6,7&quot;;</div><div class="line">let c = a.a.join(&quot; &quot;);    // b = &quot;1 2 3 4 5 6 7&quot;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>方法Array.join()恰好与String.split()相反，后者是通过将一个字符串分隔成几个元素来创建数组</p>
</blockquote>
<h3 id="1-2-reverse-方法"><a href="#1-2-reverse-方法" class="headerlink" title="1.2 reverse()方法"></a>1.2 reverse()方法</h3><p>Array.reverse()方法将颠倒数组中元素的顺序并返回一个颠倒后的数组。<strong>它在原数组上执行这一操作，所以说并不是创建了一个新数组</strong>，而是在已存在的数组中对元素进行重排。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a  = [1,2,3,4,5,6,7];</div><div class="line">a.reverse();    // a =  [7,6,5,4,3,2,1]</div></pre></td></tr></table></figure></p>
<h3 id="1-3-sort-方法"><a href="#1-3-sort-方法" class="headerlink" title="1.3 sort()方法"></a>1.3 sort()方法</h3><p>Array.sort()是在<strong>原数组上进行排序</strong>,返回排序后的数组。如果调用方法时不传入参数，那么它将按照字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果数组中有未定义的元素，这些元素将放在数组的末尾<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a  = [1,12,23,14,,undefined,null,NaN,56,6,7,&quot;a&quot;,&#123;&#125;,[]];</div><div class="line">a.sort();    //[[], 1, 12, 14, 23, 56, 6, 7, &quot;NaN&quot;, &#123;&#125;, &quot;a&quot;, null,undefined,undefined × 1]  </div><div class="line">//返回的NaN已经是一个字符串，说明在比较过程中将其转化成了字符串进行比较</div></pre></td></tr></table></figure></p>
<p>仔细看可以发现，上面顺序并没有按照数字大小进行排序。如果想按照其他标准进行排序，就需要提供比较函数。该函数比较前后两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>
<ul>
<li>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，在排序后的数组中 a 应该出现在 b 之后，则返回一个大于 0 的值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a  = [1,12,23,14,,undefined,null,NaN,56,6,7,&quot;a&quot;,&#123;&#125;,[]];</div><div class="line">a.sort((a,b) =&gt; &#123;return a - b&#125;);   //[null, Array(0), NaN, Object, 1, 6, 7, 12, 14, 23, 56, &quot;a&quot;,undefined, undefined × 1]</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-4-concat-方法"><a href="#1-4-concat-方法" class="headerlink" title="1.4 concat()方法"></a>1.4 concat()方法</h3><p>Array.concat() 方法用于连接两个或多个参数（数组，字符串等），<strong>该方法不会改变现有的数组，而会返回连接多个参数的一个新数组</strong>。如果传入的参数是数组，那么它将被展开，将元素添加到返回的数组中。但要注意，<strong>concat并不能递归的展开一个元素为数组的参数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3];</div><div class="line">let b = a.concat(4,5,[6,7,[9,10]]);  // b = [1,2,3,4,5,6,7,[9,10]]];</div></pre></td></tr></table></figure>
<h3 id="1-5-slice-方法"><a href="#1-5-slice-方法" class="headerlink" title="1.5 slice()方法"></a>1.5 slice()方法</h3><p>Array.slice() 方法可从已有的数组中返回指定的一个片段(slice)，或者说是子数组。<strong>它是从原数组中截取了一个片段，并返回到了一个新数组</strong>。</p>
<p>Array.slice(a,b) 它有两个参数a,b</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td><strong>必选</strong>。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td>b</td>
<td><strong>可选</strong>。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5,7,8];</div><div class="line">let b = a.slice(3);     //  [4, 5, 7, 8]</div><div class="line">let c = a.slice(3,5);   //  [4, 5]</div><div class="line">let d = a.slice(-5,-2); //  [3, 4, 5]</div><div class="line">let d = a.slice(2,1);   //  []</div></pre></td></tr></table></figure>
<p>请注意，该方法并不会修改数组，而是返回一个新的子数组。如果想删除数组中的一段元素，应该使用下面这个方法 Array.splice()。</p>
<h3 id="1-6-splice-方法"><a href="#1-6-splice-方法" class="headerlink" title="1.6 splice()方法"></a>1.6 splice()方法</h3><p>Array.splice() 方法从数组中添加/删除元素，然后<strong>返回被删除的元素</strong>。<strong>它在原数组上修改数组</strong>，并不像slice和concat那样创建新数组。注意，虽然splice和slice名字非常相似，但是执行的却是完全不同的操作。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td><strong>必选,整数</strong>。规定添加/删除项目的位置，使用负数可从数组结尾处倒着寻找位置。</td>
</tr>
<tr>
<td>howmany</td>
<td><strong>可选,整数</strong>。要删除的元素数量。如果设置为 0，则不会删除元素。如果没有选择，则默认从index开始到数组结束的所有元素</td>
</tr>
<tr>
<td>item1, …, itemX</td>
<td><strong>可选</strong>。向数组添加新的元素。</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5,7,8];</div><div class="line">let b = a.splice(3);     // a = [1,2,3]  b = [4, 5, 7, 8]</div><div class="line">-----------------------------------------------------------</div><div class="line">let c = [1,2,3,4,5,7,8]; </div><div class="line">let d = c.splice(3,5); // c = [1,2]   d = [3,4,5,7,8]</div><div class="line">-----------------------------------------------------------</div><div class="line">let e = [1,2,3,4,5,7,8]; </div><div class="line">let f = e.splice(3,2,111,222,[1,2]); // e = [1, 2, 3, 111, 222,[1,2], 7, 8]   f = [4,5]</div></pre></td></tr></table></figure>
<p>大家要记住<strong>slice()和splice()两个方法第二个参数代表的意义是不一样的</strong>。虽然这很基础，可是有时候还是会弄混。</p>
<h3 id="1-7-push-和pop-方法"><a href="#1-7-push-和pop-方法" class="headerlink" title="1.7 push()和pop()方法"></a>1.7 push()和pop()方法</h3><p>Array.push() 方法可向数组的末尾添加一个或多个元素，并<strong>返回新的长度</strong>。</p>
<p>Array.pop()方法用于删除并<strong>返回数组的最后一个元素</strong>。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5];</div><div class="line">let b = a.pop(); //a = [1,2,3,4]    b = 5</div><div class="line">let c =  a.push(1,3,5); // a = [1,2,3,4,1,3,5]  c = 7</div></pre></td></tr></table></figure></p>
<p>上面两个方法都是直接对原数组进行操作。通过上面两个方法可以实现一个先进后出的栈。</p>
<h3 id="1-8-unshift和shift-方法"><a href="#1-8-unshift和shift-方法" class="headerlink" title="1.8 unshift和shift()方法"></a>1.8 unshift和shift()方法</h3><p>unshift，shift()的方法行为和push()，pop()非常相似，只不过他们是对数组的头部元素进行插入和删除。</p>
<p>Array.unshift() 方法可向数组的头部添加一个或多个元素，并<strong>返回新的长度</strong>。</p>
<p>Array.shift()方法用于删除并<strong>返回数组的第一个元素</strong>。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,5];</div><div class="line">let b = a.shift(); //a = [2,3,4,5]    b = 1</div><div class="line">let c =  a.unshift(1,3,5); // a = [1,3,5,2,3,45]  c = 7</div></pre></td></tr></table></figure></p>
<h3 id="1-9-toString-和toLocaleString-方法"><a href="#1-9-toString-和toLocaleString-方法" class="headerlink" title="1.9 toString()和toLocaleString()方法"></a>1.9 toString()和toLocaleString()方法</h3><p>和所有javascript的对象一样，数组也有toString()方法，这个方法可以将数组的每一个元素转化成字符串(如果必要的话，就调用元素的toString()方法)，然后输出字符串的列表，字符串之间用逗号隔开。(用我的话来理解，其实就是遍历数组元素调用每个元素自身的toString()方法，然后用逗号连接)</p>
<p>toString()的返回值和没有参数的join()方法返回的字符串相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = let e = [1,undefined,null,Boolean,&#123;&#125;,[],function()&#123;console.log(1);&#125;];</div><div class="line">let b = a.toString();   // b = &quot;1,,,function Boolean() &#123; [native code] &#125;,[object Object],,function ()&#123;console.log(1);&#125;&quot;</div></pre></td></tr></table></figure></p>
<p>注意，输出的结果中，返回的数组值周围没有括号。</p>
<p>toLocaleString方法是toString()方法的<strong>本地化版本</strong>。它是使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</p>
<p>虽然是两个方法，但是一般元素两个方法的输出结果却基本是一样的，去网上找了相关文章，发现只有两种情况比较有区分，一个是时间，一个是4位数字以上的数字,举例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let a = 1111;</div><div class="line">let b = a.toLocaleString();   // b = &quot;1,111&quot;</div><div class="line">let c = a.toString();   // c = &quot;1111&quot;;</div><div class="line">-------------------------------------------------------</div><div class="line">let date = new Date();</div><div class="line">let d = date.toString();    // d = &quot;Sun Sep 03 2017 21:52:18 GMT+0800 (中国标准时间)&quot;</div><div class="line">let e = date.toLocaleString();  //e = &quot;2017/9/3 下午9:52:18&quot;</div></pre></td></tr></table></figure></p>
<p>好吧，这个api和数组关系不大。。。主要还是和数组中元素自身有关。啊哈哈，尴尬。</p>
<h3 id="1-10-valueOf"><a href="#1-10-valueOf" class="headerlink" title="1.10 valueOf()"></a>1.10 valueOf()</h3><p>Array.valueOf()方法在日常中用的比较少，该方法继承与Object。javascript中许多内置对象都针对自身重写了该方法，数组Array.valueOf()直接返回自身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let a = [1,&quot;1&quot;,&#123;&#125;,[]];</div><div class="line">let b = a.valueOf();</div><div class="line">a === b; // true</div></pre></td></tr></table></figure></p>
<hr>
<blockquote>
<p>好啦，关于ES3的方法就不详细描述了，我相信大家基本上都已经完全是烂熟于心的那种，唯一可能需要加强记忆的就是一些参数含义，返回数据这些了。</p>
</blockquote>
<hr>
<h2 id="2-ES5中的数组方法"><a href="#2-ES5中的数组方法" class="headerlink" title="2 ES5中的数组方法"></a>2 ES5中的数组方法</h2><ol>
<li>ES5中的数组方法在各大浏览器的兼容性</li>
</ol>
<ul>
<li>Opera 11+</li>
<li>Firefox 3.6+</li>
<li>Safari 5+</li>
<li>Chrome 8+</li>
<li>Internet Explorer 9+</li>
</ul>
<p>2.Array在ES5新增的方法中接受两个参数，第一个参数都是function类型，必选，默认有传参，这些参数分别是：</p>
<ul>
<li>currentValue : 数组当前项的值</li>
<li>index : 数组当前项的索引</li>
<li>array : 数组对象本身</li>
</ul>
<p>第二个参数是当执行回调函数时指向的this(参考对象)，不提供默认为window，严格模式下为undefined。</p>
<p>以forEach举例</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback, thisArg)</div><div class="line"></div><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">    //do something</div><div class="line">&#125;, thisArg)</div></pre></td></tr></table></figure></p>
<p><strong>例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//demo,注意this指向</div><div class="line">//我这个demo没有用箭头函数来测试</div><div class="line">let a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</div><div class="line"></div><div class="line">a.forEach(function(currentValue, index, array)&#123;</div><div class="line">    this.info(currentValue, index, array);</div><div class="line">&#125;,&#123;info:function(value,index,array)&#123;</div><div class="line">    console.log(`当前值$&#123;value&#125;，下标$&#123;index&#125;,数组$&#123;array&#125;`)&#125;</div><div class="line">&#125;);</div><div class="line">function info(value,index,array)&#123;</div><div class="line">    console.log(`外放方法 ： 当前值$&#123;value&#125;，下标$&#123;index&#125;,数组$&#123;array&#125;`)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 当前值a,下标0,数组a,b,c</div><div class="line">// 当前值b,下标1,数组a,b,c</div><div class="line">// 当前值c,下标2,数组a,b,c</div></pre></td></tr></table></figure></p>
<p>3.ES5中的所有关于遍历的方法按升序为数组中含有效值的每一项执行一次callback函数，那些<strong>已删除（使用delete方法等情况）或者未初始化的项</strong>将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。</p>
<p><strong>例子：数组哪些项被跳过了</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function logArrayElements(element, index, array) &#123;</div><div class="line">    console.log(`a[$&#123;index&#125;] = $&#123;element&#125;`);</div><div class="line">&#125;</div><div class="line">let xxx;  //定义未赋值</div><div class="line">let a = [1,2,&quot;&quot;, ,undefined,xxx,3];</div><div class="line">delete a[1];  // 移除 2</div><div class="line">a.forEach(logArrayElements);</div><div class="line"></div><div class="line">// a[0] = 1</div><div class="line">// 注意索引1被跳过了，因为在数组的这个位置没有项 被删除了</div><div class="line">// a[2] = &quot;&quot;</div><div class="line">// 注意索引3被跳过了，因为在数组的这个位置没有项,可以理解成没有被初始化</div><div class="line">// a[4] = undefined</div><div class="line">// a[5] = undefined</div><div class="line">// a[6] = 3</div></pre></td></tr></table></figure></p>
<p>好了，上面3点基本上是ES5中所有方法的共性，下面就不重复述说了。开始正文解析每个方法的不同了</p>
<hr>
<h3 id="2-1-forEach"><a href="#2-1-forEach" class="headerlink" title="2.1 forEach()"></a>2.1 forEach()</h3><p>Array.forEach() 为每个数组元素执行callback函数；不像map() 或者reduce() ，<strong>它总是返回 undefined值</strong>，并且不可链式调用。典型用例是在一个链的最后执行副作用。</p>
<blockquote>
<p>注意： 没有办法中止或者跳出 forEach 循环，除了抛出一个异常。如果你需要跳出函数，推荐使用Array.some。如果可以，新方法 find() 或者findIndex() 也可被用于真值测试的提早终止。</p>
</blockquote>
<p><strong>如果数组在迭代时被修改了</strong></p>
<p>下面的例子输出”one”, “two”, “three”。当到达包含值”two”的项时，整个数组添加了一个项在第一位，这导致所有的元素下移一个位置。此时在下次执行回调中，因为元素 “two”符合条件，结果一直增加元素，直到遍历次数完毕。forEach()不会在迭代之前创建数组的副本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let a = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];</div><div class="line">let b = a.forEach((value,index,arr) =&gt; &#123;</div><div class="line">  if (value === &quot;two&quot;) &#123;</div><div class="line">    a.unshift(&quot;zero&quot;);</div><div class="line">  &#125;</div><div class="line">  return &quot;new&quot; + value</div><div class="line">&#125;);</div><div class="line">// one,0,[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div><div class="line">// two,1,[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div><div class="line">// two,2,[&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div><div class="line">// two,3,[&quot;zero&quot;,&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</div></pre></td></tr></table></figure></p>
<p>看完例子可以发现，使用 forEach 方法处理数组时，数组元素的范围是在callback方法第一次调用之前就已经确定了。在 forEach 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 forEach 方法遍历到它们的那一个索引时的值。</p>
<h3 id="2-2-map"><a href="#2-2-map" class="headerlink" title="2.2 map()"></a>2.2 map()</h3><p>Array.map 方法会给原数组中的每个元素都按顺序调用一次callback函数。callback每次执行后的返回值（没有指定返回值则返回undefined）组合起来形成一个新数组。</p>
<p><strong>例子：返回每个元素的平方根的数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,4,9];</div><div class="line">let b = a.map((value) =&gt; &#123;</div><div class="line">   return Math.sqrt(value);    //如果没有return，则默认返回undefined</div><div class="line">&#125;);</div><div class="line">// b= [1,2,3]</div></pre></td></tr></table></figure></p>
<h3 id="2-3-filter"><a href="#2-3-filter" class="headerlink" title="2.3 filter()"></a>2.3 filter()</h3><p>Array.filter()为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中</p>
<p><strong>例子：数组去重</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3,4,32,6,79,0,1,1,8];</div><div class="line">let b = a.filter((value,index,arr) =&gt; &#123;</div><div class="line">   return arr.indexOf(value) === index;</div><div class="line">&#125;);</div><div class="line">// b = [1, 2, 3, 4, 32, 6, 79, 0, 8]</div></pre></td></tr></table></figure></p>
<h3 id="2-4-some"><a href="#2-4-some" class="headerlink" title="2.4 some()"></a>2.4 some()</h3><p>Array.some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，<strong>some 将会立即返回 true。否则，some 返回 false</strong>。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
<p><strong>例子：查看数组内是否含有大于0的元素</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [-1,4,9];</div><div class="line">let b = a.some((value) =&gt; &#123;</div><div class="line">   return value &gt; 0;    //如果没有return，则默认返回undefined，将无法告诉some判断</div><div class="line">&#125;);</div><div class="line">// b = true</div></pre></td></tr></table></figure></p>
<blockquote>
<p>some方法可以理解成拥有跳出功能的forEach()函数，可以用在在一些需要中断函数的地方</p>
<h3 id="2-5-every"><a href="#2-5-every" class="headerlink" title="2.5 every()"></a>2.5 every()</h3></blockquote>
<p>Array.every() 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。</p>
<p><strong>例子：检测所有数组元素的大小，是否都大于0</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [-1,4,9];</div><div class="line">let b = a.every((value) =&gt; &#123;</div><div class="line">   return value &gt; 0;    //如果没有return，则默认返回undefined</div><div class="line">&#125;);</div><div class="line">// b = false</div></pre></td></tr></table></figure></p>
<h4 id="2-6-indexOf"><a href="#2-6-indexOf" class="headerlink" title="2.6 indexOf()"></a>2.6 indexOf()</h4><p>Array.indexOf()使用严格相等（strict  equality，即===）进行判断searchElement与数组中包含的元素之间的关系。</p>
<p>Array.indexOf()提供了两个参数，第一个searchElement代表要查询的元素，第二个代表fromIndex表示从哪个下标开始查找，默认为0。</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.indexOf(searchElement)</div><div class="line">arr.indexOf(searchElement, fromIndex = 0)</div></pre></td></tr></table></figure></p>
<p>Array.indexOf()会返回首个被找到的元素在数组中的索引位置; 若没有找到则返回 -1</p>
<p><strong>例子：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let array = [2, 5, 9];</div><div class="line">array.indexOf(2);     // 0</div><div class="line">array.indexOf(7);     // -1</div><div class="line">array.indexOf(9, 2);  // 2</div><div class="line">array.indexOf(2, -1); // -1</div><div class="line">array.indexOf(2, -3); // 0</div></pre></td></tr></table></figure></p>
<h3 id="2-7-lastIndexOf"><a href="#2-7-lastIndexOf" class="headerlink" title="2.7 lastIndexOf()"></a>2.7 lastIndexOf()</h3><p>Array.lastIndexOf()就不细说了，其实从名字大家也可以看出来，indexOf是正向顺序查找，lastIndexOf是反向从尾部开始查找，但是返回的<strong>索引下标仍然是正向的顺序索引</strong><br>。<br><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.lastIndexOf(searchElement, fromIndex = arr.length - 1)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，只是查找的方向相反，fromIndex和返回的索引都是正向顺序的，千万不要搞混了（感觉我这么一说，大家可能搞混了，捂脸）。</p>
</blockquote>
<p><strong>例子：各种情况下的的indexOf</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var array = [2, 5, 9, 2];</div><div class="line">var index = array.lastIndexOf(2);   // index = 3</div><div class="line">index = array.lastIndexOf(7);   // index = -1</div><div class="line">index = array.lastIndexOf(2, 3);    // index = 3</div><div class="line">index = array.lastIndexOf(2, 2);    // index = 0</div><div class="line">index = array.lastIndexOf(2, -2);   // index = 0</div><div class="line">index = array.lastIndexOf(2, -1);   // index = 3</div></pre></td></tr></table></figure></p>
<h3 id="2-8-reduce"><a href="#2-8-reduce" class="headerlink" title="2.8 reduce()"></a>2.8 reduce()</h3><p>Array.reduce() 为数组中的每一个元素依次执行回调函数,最后返回一个函数累计处理的结果。</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)</div></pre></td></tr></table></figure></p>
<p>reduce的回调函数中的参数与前面的不同，多了第一个参数，是上一次的返回值</p>
<ul>
<li>accumulator : 上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue : 数组当前项的值</li>
<li>currentIndex : 数据当前项的索引。第一次遍历时，如果提供了 initialValue ，从0开始；否则从1开始</li>
<li>array : 调用 reduce 的数组</li>
<li>initialValue : 可选项，其值用于第一次调用 callback 的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。<strong>空数组调用reduce时没有设置初始值将会报错</strong>。</li>
</ul>
<p><strong>例子：数组求和</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let sum = [0, 1, 2, 3].reduce(function (o,n) &#123;</div><div class="line">  return o + n;</div><div class="line">&#125;);</div><div class="line">// sum = 6</div></pre></td></tr></table></figure></p>
<p>对了，当回调函数第一次执行时，accumulator 和 currentValue 的取值有两种情况：</p>
<ul>
<li>调用 reduce 时提供initialValue，accumulator 取值为 initialValue ，currentValue 取数组中的第一个值；</li>
<li>没有提供 initialValue ，accumulator 取数组中的第一个值，currentValue 取数组中的第二个值。</li>
</ul>
<p><strong>例子：reduce数组去重</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[1,2,3,4,5,6,78,4,3,2,21,1].reduce(function(accumulator,currentValue)&#123;</div><div class="line">	if(accumulator.indexOf(currentValue) &gt; -1)&#123;</div><div class="line">		return accumulator;</div><div class="line">	&#125;else&#123;</div><div class="line">		accumulator.push(currentValue);</div><div class="line">        return accumulator;</div><div class="line">	&#125;</div><div class="line">&#125;,[])</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 ：如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>
</blockquote>
<h3 id="2-9-reduceRight-方法"><a href="#2-9-reduceRight-方法" class="headerlink" title="2.9 reduceRight()方法"></a>2.9 reduceRight()方法</h3><p>Array.reduceRight() 为数组中的每一个元素依次执行回调函数，方向相反，从右到左,最后返回一个函数累计处理的结果。</p>
<p>因为这个方法和reduce方法基本是一模一样的，除了方法相反，所以就不详细的再写一遍了</p>
<h3 id="2-10-isArray-方法"><a href="#2-10-isArray-方法" class="headerlink" title="2.10 isArray()方法"></a>2.10 isArray()方法</h3><p>之所以将这个方法放在最后，是因为这个方法和前面的不太一致，是用于确定传递的值是否是一个 Array,使用方法也很简单</p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Array.isArray([1,2,3]);  //true</div><div class="line">let b = Array.isArray(document.getElementsByTagName(&quot;body&quot;));  //类数组也为false</div></pre></td></tr></table></figure></p>
<p>不过感觉除非是临时判断，不然一般也不会用这个方法去判断，一般还是下面这种万金油型的吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.prototype.toString.call([]).slice(8, -1) === &quot;Array&quot;;//true</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>好啦，关于ES5的方法基本上就讲到这里了，感觉自己在深入去看了一些文章之后，还是有一些额外的收获的。比如对reduce这个平时不常用的方法了解更加深刻了，感觉之前很多遍历收集数据的场景其实用reduce更加方便。</p>
</blockquote>
<hr>
<h2 id="3-ES6中的数组方法"><a href="#3-ES6中的数组方法" class="headerlink" title="3 ES6中的数组方法"></a>3 ES6中的数组方法</h2><blockquote>
<p>不同于es5主要以遍历方法为主，es6的方法是各式各样的，不过必须要说一句，在性能上，es6的效率基本上是最低的。</p>
</blockquote>
<h3 id="3-1-…方法——concat方法的增强"><a href="#3-1-…方法——concat方法的增强" class="headerlink" title="3.1 …方法——concat方法的增强"></a>3.1 …方法——concat方法的增强</h3><p>英文名字叫做Spread syntax，中文名字叫做扩展运算符。</p>
<h3 id="3-2-of-方法"><a href="#3-2-of-方法" class="headerlink" title="3.2 of()方法"></a>3.2 of()方法</h3><p>Array.of()方法可以将传入参数以顺序的方式返回成一个新数组的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let a = Array.of(1, 2, 3); // a = [1, 2, 3]</div></pre></td></tr></table></figure></p>
<p>其实，刚看到这个api和他的用途，还是比较懵逼的，因为看上去这个方法就是直接将传入的参数变成一个数组之外，就没有任何区别了，那么我为什么不直接用以前的写法去实现类似的效果呢，比如 let ＝ [1,2,3];而且看上去也更加直接。然后我去翻了下最新的ECMAScript草案，其中有这么一句话</p>
<blockquote>
<p>The of function is an intentionally generic factory method; it does not require that its this value be the Array constructor. Therefore it can be transferred to or inherited by other constructors that may be called with a single numeric argument.</p>
</blockquote>
<p>自己理解了一下，其实大概意思就是说为了弥补Array构造函数传入单个函数的不足，所以出了一个of这个更加通用的方法，举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = new Array(1);//a = [undefined × 1]</div><div class="line">let b = new Array(1,2);// b = [1,2]</div></pre></td></tr></table></figure></p>
<p>大家可以注意到传入一个参数和传入两个参数的结果，完全是不一样的，这就很尴尬了。而为了避免这种尴尬，es6则出了一种通用的of方法，不管你传入了几个参数，都是一种相同类型的输出结果。</p>
<p>不过我好奇的是，如果只传入几个参数，为什么不直接let a = [1,2,3];效率和直观性也更加的高。如果要创建一个长度的数组，我肯定还是选let a = new Array(10000),这种形式，实在没有感觉到Array.of的实用场景，希望大家可以给我点指导。</p>
<h3 id="3-2-from-方法"><a href="#3-2-from-方法" class="headerlink" title="3.2 from()方法"></a>3.2 from()方法</h3><p>Array.from()方法从一个类似数组（拥有一个 length 属性和若干索引属性的任意对象）或可迭代的对象(String, Array, Map, Set和 Generator)中创建一个新的数组实例。</p>
<p>我们先查看Array.from()的语法</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Array.from(arrayLike, mapFn, thisArg)</div></pre></td></tr></table></figure></p>
<p>从语法中，我们可以看出Array.from()最基本的功能是将一个类数组的对象转化成数组，然后通过第二个和第三个参数可以对转化成功后的数组再次执行一次遍历数据map方法,也就是Array.from(obj).map(mapFn, thisArg)。</p>
<blockquote>
<p>对了额外说一句，这个方法的性能很差，和直接的for循环的性能对比了一下，差了百倍不止。</p>
</blockquote>
<p><strong>例子 :将一串数字字符串转化为数组</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = Array.from(&quot;242365463432&quot;,(value) =&gt; return value * 2);</div><div class="line">//a = [4, 8, 4, 6, 12, 10, 8, 12, 6, 8, 6, 4]</div></pre></td></tr></table></figure></p>
<h3 id="3-4-copyWithin-方法"><a href="#3-4-copyWithin-方法" class="headerlink" title="3.4 copyWithin()方法"></a>3.4 copyWithin()方法</h3><p>Array.copyWithin方法，在当前数组内部，将指定位置的成员<strong>浅复制</strong>到其他位置（会覆盖原有成员），然后<strong>返回当前数组</strong>。也就是说，使用这个方法，会修改当前数组。</p>
<blockquote>
<p>这个方法有点复杂，光看描述可能大家未必能轻易理解，大家可以先看下语法，再看demo配合理解，而且自己没有想到这个方法合适的应用场景。网上也没又看到相关使用场景。但是讲道理，这个方法设计出来，肯定是经过深思熟虑的，如果大家有想到，欢迎评论给我，谢谢。</p>
</blockquote>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.copyWithin(target, start, end)</div><div class="line">//arr.copyWithin(目标索引, 源开始索引, 结束源索引)</div></pre></td></tr></table></figure></p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 将3号位复制到0号位</div><div class="line">[1, 2, 3, 4, 5].copyWithin(0, 3, 4);    // [4, 2, 3, 4, 5]</div><div class="line"></div><div class="line">// 将2号位复制到0号位</div><div class="line">[1, 2, 3, 4, 5].copyWithin(0, 2, 5);    //[3, 4, 5, 4, 5]</div><div class="line"> </div><div class="line"> // 将3号位复制到0号位</div><div class="line">[1, 2, 3, 4, 5].copyWithin(4, 1, 4);    //[1, 2, 3, 4, 2]</div></pre></td></tr></table></figure></p>
<p>第一个是常规的例子，大家可以对比看第二个可以发现，这个方法是先浅复制了数组一部分暂时存储起来，然后再从目标索引处开始一个个覆盖后面的元素，直到这段复制的数组片段全部粘贴完。</p>
<p>再看第三个例子，可以发现当复制的数据片段从目标索引开始粘贴时，如果超过了长度，它将停止粘贴，这说明<strong>它不会改变数据的 length，但是会改变数据本身的内容</strong>。</p>
<p>Array.copyWithin可以理解成复制以及粘贴序列这两者是为一体的操作;即使复制和粘贴区域重叠，粘贴的序列也会有拷贝来的值。</p>
<h3 id="3-5-find-和-findIndex-方法"><a href="#3-5-find-和-findIndex-方法" class="headerlink" title="3.5 find() 和 findIndex()方法"></a>3.5 find() 和 findIndex()方法</h3><p>Array.find()方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。<br> Array.findIndex() 方法返回数组中满足提供的测试函数的第一个元素的值的索引。否则返回 -1。</p>
<p> 这两个方法其实使用非常相似，使用场景有点像ES5中Array.some，都是在找到第一个满足条件的时候，跳出循环，区别的是，三种返回的值完全不一样，我想这也许是为什么要在ES6中增加这两个API的原因吧，可以理解成是数组的方法的补足。</p>
<p>  <strong>例子：三个方法各自的返回值</strong><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> let a = [1,2,3,4,5].find((item)=&gt;&#123;return item &gt; 3&#125;);   // a = 4 返回第一个符合结果的值</div><div class="line">let b = [1,2,3,4,5].findIndex((item)=&gt;&#123;return item &gt; 3&#125;);  // b = 3 返回第一个符合结果的下标</div><div class="line">let c = [1,2,3,4,5].some((item)=&gt;&#123;return item &gt; 3&#125;);    // c = true 返回是否有符合条件的Boolean值</div><div class="line"></div><div class="line">-----------------不满足条件--------------------</div><div class="line"> let a = [1,2,3,4,5].find((item)=&gt;&#123;return item &gt; 6&#125;);   // a = undefined</div><div class="line">let b = [1,2,3,4,5].findIndex((item)=&gt;&#123;return item &gt; 6&#125;);  // b = -1</div><div class="line">let c = [1,2,3,4,5].some((item)=&gt;&#123;return item &gt; 6&#125;);    // c = false</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：find()和findIndex()方法无法判断NaN,可以说是内部用 ===判断，不同于ES7中的include方法。不过这个判断方式是另外一个话题，不在本文详述了，感兴趣的同学可以去查一下。</p>
</blockquote>
<p>其实还可以发现，Array.find() 方法只是返回第一个符合条件的元素，它的增强版是es5中Array.filter()方法，返回所有符合条件的元素到一个新数组中。可以说是当用find方法时考虑跟多的是跳出吧。</p>
<p>我感觉这4个方法配合相应的回调函数基本上可以完全覆盖大多数需要数组判断的场景了，大家觉得呢？</p>
<h3 id="3-5-fill方法"><a href="#3-5-fill方法" class="headerlink" title="3.5 fill方法"></a>3.5 fill方法</h3><p>Array.fill()方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素,<strong>返回原数组</strong></p>
<p>这个方法的使用也非常简单，大家基本上看个语法和demo就能懂了。需要注意的是，这个方法是返回数组本身，还有一点就是，类数组不能调用这个方法，刚刚自己去改了MDN上面的文档。</p>
<p><strong>语法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.fill(value) </div><div class="line">arr.fill(value, startIndex) </div><div class="line">arr.fill(value, startIndex, endIndex)</div></pre></td></tr></table></figure></p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a = new Array(10);</div><div class="line">a.fill(1);  // a = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];</div><div class="line">let b = [1,2,34,5,6,7,8].fill(3,4);    //b =  [1, 2, 34, 5, 3, 3, 3];</div><div class="line">let c = [1,2,34,5,6,7,8].fill(3,2,5);   // c =  [1, 2, 3, 3, 3, 7, 8];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>个人感觉这个方法初始化数组挺有用的，自己一周每次测试数据时，只要new Array().fill(1);,比以前遍历直观方便多了</p>
</blockquote>
<h3 id="3-6-entries-，keys-values-方法"><a href="#3-6-entries-，keys-values-方法" class="headerlink" title="3.6 entries()，keys(),values()方法"></a>3.6 entries()，keys(),values()方法</h3><p>Array.entries()将数组转化成一个中包含<strong>每个索引的键/值对</strong>的Array Iterator对象</p>
<p>Array.keys()将数组转化成一个中包含<strong>每个索引的键</strong>的Array Iterator对象</p>
<p>Array.values()将数组转化成一个中包含<strong>每个索引的值</strong>的Array Iterator对象。</p>
<blockquote>
<p>Array.values()方法chrome浏览器并不支持，</p>
</blockquote>
<p>之所以将这三个方法放在一起是有原因的额，大家可以看这三个方法其实都是一个数组转化为一种新的数据类型——返回新的Array Iterator对象，唯一区别的是转化之后的元素不一样。跟他们的名字一样，entries()方法转化为全部的键值对，key()方法转化为键，value()保留值。</p>
<p><strong>例子：观察各个迭代器遍历输出的东西</strong></p>
<p><strong>Array.entries()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let a = [1,2,3].entries();</div><div class="line">for(let i of a)&#123;console.log(i);&#125;</div><div class="line">//[0, 1]</div><div class="line">//[1, 2]</div><div class="line">//[2, 3]</div></pre></td></tr></table></figure></p>
<p><strong>Array.keys()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let b = [1,2,3].keys();</div><div class="line">for(let i of b)&#123;console.log(i);&#125;</div><div class="line">//0</div><div class="line">//1</div><div class="line">//2</div></pre></td></tr></table></figure></p>
<p><strong>Array.values()</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let c = [1,2,3].values();</div><div class="line">for(let i of c)&#123;console.log(i);&#125;</div><div class="line">//1</div><div class="line">//2</div><div class="line">//3</div></pre></td></tr></table></figure></p>
<blockquote>
<p>关于迭代器这个东西，自己说不上什么，因为自己没有亲自用过，如果大家有什么见解课可以评论给我，我来补充和学习一下</p>
</blockquote>
<h2 id="4-ES7中的数组方法"><a href="#4-ES7中的数组方法" class="headerlink" title="4 ES7中的数组方法"></a>4 ES7中的数组方法</h2><h3 id="4-1-includes-方法"><a href="#4-1-includes-方法" class="headerlink" title="4.1 includes()方法"></a>4.1 includes()方法</h3><p>Array.includes方法返回一个布尔值，表示某个数组是否包含给定的值，如果包含，则返回true，否则返回false,与<strong>字符串的includes方法</strong>类似。</p>
<p>这个方法大家可以看作是ES5中Array.indexOf的语义增强版，“includes”这个是否包含的意思，直接返回Boolean值，比起原来的indexOf是否大于-1,显得更加直观,我就是判断有没有包含哪个值</p>
<p><strong>语法</strong>，使用方法和indexof一模一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.includes(searchElement)</div><div class="line">arr.includes(searchElement, fromIndex)</div></pre></td></tr></table></figure></p>
<p><strong>例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let array = [2, 5, 9];</div><div class="line">array.includes(2);     // true</div><div class="line">array.includes(7);     // false</div><div class="line">array.includes(9, 2);  // true</div><div class="line">array.includes(2, -1); // false</div><div class="line">array.includes(2, -3); // true</div></pre></td></tr></table></figure></p>
<hr>
<p>方法还真是tmd多啊，感觉基本上应该是更新完了，前后两星期花了我4天时间吧，还是挺累的。不过收货还是很多，比如知道了ES5的方法基本上都有第二个this指向的参数，重新认识了reduce方法，感觉自己之前很多场景用reduce更好，重新熟悉了一些ES6的方法可以试用有些场景</p>
<p>如果能看到最后的，感觉你也是够累的，哈哈哈。<br>既然这么累，点颗星吧</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/24/理解jquery的深拷贝源码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/24/理解jquery的深拷贝源码/" itemprop="url">理解jquery的深拷贝</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-24T23:47:44+08:00">
                2017-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/24/理解jquery的深拷贝源码/" class="leancloud_visitors" data-flag-title="理解jquery的深拷贝">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  1,855
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>好像自从使用框架之后，对jquery的依赖越来越低了，其好像已经慢慢作为一个工具库的存在了。新项目商量之下，为了减小文件大小，干脆直接不用jquer2，对于一些需要的工具函数直接从jquery提取到一个自己写的工具文件tool.js中。在提取的过程中，也慢慢理解了jquery一些工具函数的源码</p>
</blockquote>
<p>深拷贝和浅拷贝的使用场景不同，并没有好坏之分，像对一些基本数据类型，直接可以使用浅拷贝对处理数据。但是对于基本引用类型如嵌套对象，数组（包含着对象的数组），那么就需要使用到深拷贝了。</p>
<blockquote>
<p>不想看前面深浅拷贝对比的，可以直接拉到第二章看jquery源码实现</p>
</blockquote>
<hr>
<h4 id="1-浅拷贝解析"><a href="#1-浅拷贝解析" class="headerlink" title="1.浅拷贝解析"></a>1.浅拷贝解析</h4><p>原生js也有一些提供拷贝的函数，比如数组的Array.slice(0),Array.concat()，对象的Object.create(),Object.assign()等等，但是都是浅拷贝，遇到二维数组，嵌套对象就通通失败了（以前不懂的时候，真的被坑的不要不要的啊）。</p>
<p>比如下面这个例子，都是在只有基本数据类型的情况下，使用浅拷贝就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,34,5,67,8,9];</div><div class="line">let cloneArr = arr.slice(4);</div><div class="line">console.log(cloneArr);  //  [67, 8, 9]</div><div class="line"></div><div class="line">cloneArr[0] = 100;  //  修改cloneArr</div><div class="line">console.log(arr);   //  [1,2,34,5,67,8,9],修改cloneArr不影响原数组arr</div><div class="line"></div><div class="line">----------------</div><div class="line"></div><div class="line">let obj = &#123;a : 1,b : 2,c : 3,&#125;;</div><div class="line">let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象</div><div class="line">console.log(cloneObj); //   cloneObj = &#123;a : 1,b : 2,c : 3,&#125;;</div><div class="line"></div><div class="line">cloneObj.a = 444;   //修改对象</div><div class="line">console.log(obj);   //  obj = &#123;a : 1,b : 2,c : 3,&#125;; 修改拷贝对象不影响源对象</div></pre></td></tr></table></figure></p>
<p>但是如果以上例子将基本数据类型换成引用类型Object和Array呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2,&#123;a : 3&#125;,&#123;b : 4&#125;,5];</div><div class="line">let cloneArr = arr.slice(2);</div><div class="line">console.log(cloneArr);  //  [&#123;a : 3&#125;,&#123;b : 4&#125;,5];</div><div class="line"></div><div class="line">cloneArr[0].a = 100;  //  修改cloneArr</div><div class="line">console.log(arr);   //  [1,2,&#123;a : 100&#125;,&#123;b : 4&#125;,5],修改cloneArr影响原数组arr</div><div class="line"></div><div class="line">----------------</div><div class="line"></div><div class="line">let obj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;</div><div class="line">let cloneObj = Object.assign(&#123;&#125;,obj);// 将拷贝的属性值拷贝到目标对象，然后返回目标对象</div><div class="line">console.log(cloneObj); //   cloneObj = &#123;a : &#123;aa : 1&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;;</div><div class="line"></div><div class="line">cloneObj.a.aa = 100;   //修改对象</div><div class="line">console.log(obj);   //  obj = &#123;a : &#123;aa : 100&#125;,b : &#123;bb : 2&#125;,c : 3,&#125;; 修改拷贝对象影响到了源对象</div></pre></td></tr></table></figure>
<p>为什么会这样子，原因其实也不复杂。js内存分为栈内存和堆内存。所有的基本数据类型都是存储在栈内存中，而引用类型则是存储在堆内存中，提供了一个地址放在了栈内存中。当我们要获取引用类型的值时，先从栈内存获得地址，再根据地址去堆内存中获得值。因此也叫按引用访问。</p>
<blockquote>
<p>(去网上浅拷贝了一张图片，因为拷贝了一个图片地址)<br><img src="http://img.blog.csdn.net/20141212220233511?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGRkMTk5MTA1MDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="去网上浅拷贝了一张图片，拷贝了一个图片地址"></p>
</blockquote>
<p>而我们上面例子中，每个数组和对象每个属性存储的引用类型obj其实是个地址，我们只是简单的拷贝了属性值，其实就是拷贝了一个地址。所以我们在新对象里进行修改时，由于是通过同一个地址修改了值。因为和原对象共用了一个地址，所以自然就修改了原对象的值了。</p>
<h4 id="2-深拷贝解析"><a href="#2-深拷贝解析" class="headerlink" title="2.深拷贝解析"></a>2.深拷贝解析</h4><p>前面解析了浅拷贝。因为我们项目对大型数据处理占据了大头，其中不可避免的会经常用到深拷贝这块。那么深拷贝是怎么实现的。</p>
<p>其实也很简单，就是根据地址找到你堆内存中的值，不断递归深入拷贝下去，直到为基本数据类型为止，接下去就贴上深拷贝代码。</p>
<p>在讲jquey前，还有一个很暴力的方式<strong>JSON.parse()和JSON.stringify()</strong>;缺点是</p>
<ul>
<li>数据不能包含函数。</li>
<li>如果某个对象属性值为null，会形成一个对象的闭环<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">    a: 1,</div><div class="line">    b: 2,</div><div class="line">	c: [1,2,3],</div><div class="line">    d: function() &#123; </div><div class="line">        console.log(&quot;asdfghj&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">let result1 = JSON.stringify(target);</div><div class="line">console.log(result1); //    输出结果为&quot;&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[1,2,3]&#125;&quot;，函数直接没了</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">  foo: &#123;</div><div class="line">    name: &apos;foo&apos;,</div><div class="line">    bar: &#123;</div><div class="line">      name: &apos;bar&apos;</div><div class="line">      baz: &#123;</div><div class="line">        name: &apos;baz&apos;,</div><div class="line">        aChild: null // 待会将指向obj.bar</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo形成环</div><div class="line">JSON.stringify(obj) // =&gt; TypeError: Converting circular personucture to JSON</div></pre></td></tr></table></figure>
</li>
</ul>
<p>好了，最后贴上jquery深拷贝的代码和自己一些理解的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">$.fn.extend = function () &#123;</div><div class="line">    //jquery喜欢在初始定义好所有的变量</div><div class="line">    let options,//  被拷贝的对象</div><div class="line">    	name,// 遍历时的属性</div><div class="line">    	src,// 返回对象本身的属性值</div><div class="line">    	copy,// 需要拷贝的内容</div><div class="line">    	copyIsArray,//  判断是否为数组</div><div class="line">    	clone,// 返回拷贝的内容</div><div class="line">    	target = arguments[0] || &#123;&#125;,</div><div class="line">    	i = 1,</div><div class="line">    	length = arguments.length,</div><div class="line">    	deep = false;// 默认为浅拷贝</div><div class="line">    	</div><div class="line">    //target 是传入的第一个参数,表示是否要深递归</div><div class="line">    if(typeof target === &apos;boolean&apos;)&#123;</div><div class="line">    	deep = target;</div><div class="line">    	//既然为boolean，则此处初始化target为第二个参数或者空对象</div><div class="line">    	target = arguments[i] || &#123;&#125;;</div><div class="line">    	// 如果传了类型为 boolean 的第一个参数，i 则从 2 开始</div><div class="line">    	i ++</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //如果传入的第一个参数不是对象或者其他，初始化为一个空对象</div><div class="line">    if(typeof target !== &apos;object&apos; &amp;&amp; $.isFunction(target))&#123;</div><div class="line">    	target = &#123;&#125;;</div><div class="line">    &#125;</div><div class="line">    //如果只传入了一个参数，表示是jquery静态方法，直接返回自身</div><div class="line">    if(i === length)&#123;</div><div class="line">    	target = this;</div><div class="line">    	i --;</div><div class="line">    &#125;</div><div class="line">    for(; i &lt; length; i ++)&#123;</div><div class="line">    	if((options = arguments[i]) !== null )&#123;</div><div class="line">            for( name in options)&#123;</div><div class="line">            	src = target[name];//获得源对象的值</div><div class="line">            	copy = options[name];//获得要拷贝对象的值</div><div class="line">            	//说是为了避免无限循环，例如 extend(true, target, &#123;&apos;target&apos;:target&#125;);</div><div class="line">            	if(target === copy) continue;</div><div class="line">            	//如果是数据正确，且是一个纯粹的对象（纯粹的对象指的是 通过 &quot;&#123;&#125;&quot; 或者 &quot;new Object&quot; 创建的）或者是一个数组的话</div><div class="line">            	if(deep &amp;&amp; copy &amp;&amp; ($.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))))&#123;</div><div class="line">                    //如果是一个数组的话</div><div class="line">                    if(copyIsArray)&#123;</div><div class="line">                        copyIsArray = false;</div><div class="line">                        clone = src &amp;&amp; Array.isArray(src) ? src : [];//判断源对象是不是数组，如果不是，直接变为空数组，拷贝属性高优先原则</div><div class="line">                    &#125; else &#123;</div><div class="line">                        clone = src &amp;&amp; $.isPlainObject(src) ? src : &#123;&#125;;//判断原对象属性是否有值，如果有的话，直接返回原值，否则新建一个空对象</div><div class="line">                    &#125;</div><div class="line">                    //继续深拷贝下去</div><div class="line">                    target[name] = $.extend(deep,clone,copy);</div><div class="line">            	&#125;else if(copy !== undefined)&#123;</div><div class="line">                    //如果不为空，则不是需要深拷贝的数据和对象，而是string,data,boolean等等，可以直接赋值</div><div class="line">                    target[name] = copy;</div><div class="line">            	&#125;</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    // 返回新的拷贝完的对象</div><div class="line">    return target;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在看上段代码中，又发现了几个好方法在业务中会用到的，可以让代码更严谨<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//判断数据类型</div><div class="line">//判断是否为纯正的数据对象</div><div class="line">isPlainObject: function( obj ) &#123;</div><div class="line">    //如果数据不正确，不是对象类型，或者是dom对象，window对象，则直接返回false</div><div class="line">    if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) &#123;</div><div class="line">    	return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //这段代码是为了兼容IE89存在的，查看是否有constructor属性，如果没有必然是数据对象</div><div class="line">    try &#123;</div><div class="line">    	if ( obj.constructor &amp;&amp;</div><div class="line">            !core_hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp;</div><div class="line">            !core_hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) &#123;</div><div class="line">            return false;</div><div class="line">    	&#125;</div><div class="line">    &#125; catch ( e ) &#123;</div><div class="line">    	return false;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //对象中key的顺序会将自身属性排在最前面遍历，如果最后一个还是自身属性，则必然所有属性都是自己的  </div><div class="line">    var key;</div><div class="line">    for ( key in obj ) &#123;&#125;</div><div class="line">    </div><div class="line">    return key === undefined || core_hasOwn.call( obj, key );</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>以上基本就是jquery.extend代码的解析了。extend是jquery中一个极其重要的方法，jquery本身就用它扩展了许多静态方法和实例方法</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/promise源码解析（译）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/promise源码解析（译）/" itemprop="url">promise源码解析（译）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T23:47:44+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/20/promise源码解析（译）/" class="leancloud_visitors" data-flag-title="promise源码解析（译）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  4,582
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  18
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最新项目中有用promise几个api，对代码结构看起来的确很爽。然后想着去网上找了几篇promise库源码解析的文章。但是看了几篇，感觉还是不能够很理解，然后看到一篇翻译文章有说道q.js库的作者有对promise实现的递进讲解，看了一下，还不错，</p>
</blockquote>
<p>Q.js作者源码分析：<a href="https://github.com/kriskowal/q/tree/v1/design" target="_blank" rel="external">Q.js作者promise递进讲解实现</a></p>
<p><a href="http://div.io/topic/1351" target="_blank" rel="external">网上找的promise源码翻译</a>。文章有些地方翻译的很好，但是对比原文发现少了一些内容，所以读起来很不顺畅。所以自己根据原文也翻译了一遍。对了，本文适合用过promise的人阅读。如果你还没有接触过。可以右转<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰的promise讲解</a></p>
<hr>
<h4 id="一、极简版异步回调"><a href="#一、极简版异步回调" class="headerlink" title="一、极简版异步回调"></a>一、极简版异步回调</h4><p>假如你正在写一个函数不立即返回值函数，需要等待几秒钟后才返回执行结果，你会怎么写呢？思考几秒钟。</p>
<p>最简单的做法自然是写一个回调函数依靠定时器来返回值，比如下面这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var oneOneSecondLater = function (callback) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        callback(1);</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这是一个很简单解决问题的方法，但是还有改进的地方，比如能够添加代码执行错误时给出提示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var maybeOneOneSecondLater = function (callback, errback) &#123;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        //进行判断情况，是执行成功的回调，还是执行错误的回调</div><div class="line">        if (Math.random() &lt; .5) &#123;</div><div class="line">            callback(1);</div><div class="line">        &#125; else &#123;</div><div class="line">            errback(new Error(&quot;Can&apos;t provide one.&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125;, 1000);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一般的做法是提供一个能同时返回值并且能抛出错误的工具。上面这个例子则演示同时提供回调和错误处理。但是这种写法实在是太定制化了，并不好。</p>
<h4 id="二、Promise基本雏形设计"><a href="#二、Promise基本雏形设计" class="headerlink" title="二、Promise基本雏形设计"></a>二、Promise基本雏形设计</h4><p>所以考虑到大多数的情况，代替最简单的返回值和抛出异常，我们更希望函数通常会返回一个对象用来表示最后执行成功或者失败的结果，而这个返回的对象就是<strong>promise</strong>。从名字上理解，promise表示承诺，那么最终这个<strong>promise</strong>（承诺）是要被<strong>resolve</strong>（履行，执行）掉的。</p>
<p>接下去我们开始迭代设计promise。我们先设计一个具有“then”方法的promise模型，通过“then”方法，我们能注册回调函数并且延迟执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var maybeOneOneSecondLater = function () &#123;</div><div class="line">    var callback;</div><div class="line">    setTimeout(function () &#123;</div><div class="line">        callback(1);</div><div class="line">    &#125;, 1000);</div><div class="line">    return &#123;</div><div class="line">        then: function (_callback) &#123;</div><div class="line">            callback = _callback;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">maybeOneOneSecondLater().then(callback1);</div></pre></td></tr></table></figure>
<p>代码写好了。但是大家仔细观察发现该方案仍然还有两个缺点</p>
<ul>
<li>一是现在方案只能执行一个添加的回调函数。最好的做法是每一个通过then添加进来的回调都能被通知到然后顺序执行。</li>
<li>二是如果这个回调函数是在promise创建好1s之后通过then添加进去，它将无法被调用。</li>
</ul>
<blockquote>
<p><strong>敲黑板，注意注意，接下去开始慢慢搭建promise了。</strong></p>
</blockquote>
<p>正常情况下，我们希望可以接收任何数量的回调，且不管是否超时，仍然可以继续注册回调。为了实现这些，我们将创建一个包含两个功能的<strong>promise对象</strong>。</p>
<p>我们暂时设计了一个defer对象，他的返回值一个包含两部分的对象（这个对象就是<strong>promise</strong>），一个用来注册观察者（就是”then方法添加回调），一个用来通知所有的观察者执行代码（就是resolve去执行之前添加的所有回调）。</p>
<p>当<strong>promise</strong>没有被<strong>resolve</strong>之前，所有回调函数会存储在一个”pengding”的数组中。</p>
<p>当<strong>promise</strong>被<strong>resolve</strong>之后，立即执行之前存储的所有回调函数，当回调函数全部执行完毕之后，我们将根据”pengding”来区分状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value;</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            value = _value</div><div class="line">            for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                pending[i](value)</div><div class="line">            &#125;</div><div class="line">            pending = undefined;</div><div class="line">        &#125;,</div><div class="line">        then(_callback)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                pending.push(_callback)</div><div class="line">            &#125;else&#123;</div><div class="line">                _callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">let oneOneSecondLater = () =&gt; &#123;</div><div class="line">    let result = defer();</div><div class="line">    setTimeout(()=&gt; &#123;</div><div class="line">        result.resolve(1);</div><div class="line">    &#125;, 1000);</div><div class="line">    return result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">oneOneSecondLater().then(callback);</div></pre></td></tr></table></figure>
<p>这开始的第一步很关键啊，因为此时我们已经可以做到</p>
<ol>
<li>可以任意时间添加任意多的回调;</li>
<li>可以人为决定什么时候resolve;</li>
<li>当promise被resolve之后，还可以添加回调，只不过此时立即就执行了</li>
</ol>
<p>但是还有一些问题，比如</p>
<ol>
<li>defer可以被resolve执行多次,我们并没有给出一个错误的提示。而且事实上为了避免恶意或者无意的不断去resolve，我们仅允许第一次调用可以通知回调并执行。</li>
<li>添加回调只能通过defer.then添加，不能链式调用,即defer.then(callback).then(callback)</li>
</ol>
<p>那么接下来我们先修正第一个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                value = _value</div><div class="line">                for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                    pending[i](value)</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;else&#123;</div><div class="line">                throw new Error(&quot;A promise can only be resolved once.&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        then(_callback)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                pending.push(_callback)</div><div class="line">            &#125;else&#123;</div><div class="line">                _callback();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好，现在我们已经保证不能重复defer.resolve()的问题了，那么我们还希望可以实现通过链式调用来添加回调。可是目前要只能通过defer().then(callback1),defer().then(callback2),defer().then(callback3)这种方式添加回调，这显然不是我们想要的方式。接下来我们将一步一步实现。</p>
<h4 id="三、promise职责分离"><a href="#三、promise职责分离" class="headerlink" title="三、promise职责分离"></a>三、promise职责分离</h4><p>但是在实现链式回调之前，为了后期结构，我们希望对我们的promise进行职责区分，一个注册观察者，一个执行观察者。根据最少授权原则，我们希望如果授权给某人一个promise，这里只允许他增加观察者；如果授权给某人resolver，他应当仅仅能决定什么时候给出解决方案。因为大量实验表明任何任何不可避免的越权行为会导致后续的改动变得很难维护。（其实就是希望把添加回调的then功能移植到promise中，从defer.then转变成defer.promise.then，保证功能的纯粹性）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [],value;</div><div class="line">    return &#123;</div><div class="line">        resolve(_value)&#123;</div><div class="line">            if(pending)&#123;</div><div class="line">                value = _value</div><div class="line">                for(let i = 0;i &lt; pending.length; i++)&#123;</div><div class="line">                    pending[i](value)</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;else&#123;</div><div class="line">                throw new Error(&quot;A promise can only be resolved once.&quot;)</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then (callback) &#123;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push(callback);</div><div class="line">                &#125; else &#123;</div><div class="line">                    callback(value);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当职责分离完之后，我们就可以接下去实现一步关键的改造</p>
<h4 id="四、promise的链式调用"><a href="#四、promise的链式调用" class="headerlink" title="四、promise的链式调用"></a>四、promise的链式调用</h4><p>上文说道要实现链式回调，我们首先要能在下一个回调函数里接受上一个回调的值。依靠上一步的职责分离的基础，我们接下来要跨非常大的一步，就是使用旧的promise去驱动新的promise。我们希望通过promise组合的使用，来实现值的传递。</p>
<p>举个例子，让你写一个相加的函数，接受两个回调函数返回的数字相加。大家可以考虑如何实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var twoOneSecondLater = function (callback) &#123;</div><div class="line">    var a, b;</div><div class="line">    var consider = function () &#123;</div><div class="line">        if (a === undefined || b === undefined)return;</div><div class="line">        callback(a + b);</div><div class="line">    &#125;;</div><div class="line">    oneOneSecondLater(function (_a) &#123;</div><div class="line">        a = _a;</div><div class="line">        consider();</div><div class="line">    &#125;);</div><div class="line">    oneOneSecondLater(function (_b) &#123;</div><div class="line">        b = _b;</div><div class="line">        consider();</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">twoOneSecondLater(function (c) &#123;</div><div class="line">    // c === 2</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面这个方法虽然做到了，但是这个方法是脆弱的，因为我们在执行相加函数时，需要额外的代码去判断相加的数字是否有效。</p>
<p>于是我们希望用更少的代码去实现上面的需求，比如就像下面这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//上面的函数如果用更少的步骤来表达就是</div><div class="line">var a = oneOneSecondLater();</div><div class="line">var b = oneOneSecondLater();</div><div class="line">var c = a.then(function (a) &#123;</div><div class="line">    return b.then(function (b) &#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>上面这个例子其实想表达的就是实现callback返回值的传递，如callback1的返回值传给callback2，将callback2的返回值传给callback3。<br>为了实现上面例子的这种效果，我们要实现以下几点</p>
<ul>
<li>每个then方法后必须要返回一个promise</li>
<li>每一个promise被resolve后，返回的必然是一个新的promise或者是一个执行过的值</li>
<li>返回的promise最终可以带着回调的值被resolve掉（这句话有点难翻译，感觉就是promise.resolve(_value)）;</li>
</ul>
</blockquote>
<p>我们实现一个函数可以将获得的值传给下一个回调使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            callback(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过考虑到有时候返回的值不仅仅是一个值，而且还可能是一个promise函数，所以我们需要加个判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            callback(value);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样子我们在使用中就不需要考虑传入的值是一个普通值还是一个promise了。</p>
<p>接下来，为了能使then方法也能返回一个promise，我们来改造下then方法；我们强制将callback的返回值传入下一个promise并立即返回。<br>这个例子存储了回调的值，并在下一个回调中执行了。但是上面第三点没有实现，因为返回值可能是一个promise，那么我们继续改进一下方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if(value &amp;&amp; typeof value.then === &quot;function&quot;)&#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        then(callback)&#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这一步增强之后，基本上就可以做到获得上一个回调值并不断链式调用下去了。</p>
<p>接下去我们考虑到一种比较复杂的情况，就是defer中存储的回调会在未来某个时间调用。于是我们需要在defer里面将回调进行一次封装，我们将回调中执行完后通过then方法去驱动下一个promise并传递一个返回值。</p>
<p>此外，<strong>resolve</strong>方法应该能处理本身是一个promise的情况，resolve可以将值传递给promise。因为不管是ref还是defer都可以返回一个then方法。如果promise是ref类型的，将会通过then(callback)立即执行回调。如果是promise是defer类型的，callback暂时被存储起来，依靠下一个then(callback)调用才能执行；所以变成了callback可以监听一个新的promise以便能获取完全执行后的value。</p>
<p>根据以上要求，得出了下面最终版的promise<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">let isPromise = (value) =&gt; &#123;</div><div class="line">    return value &amp;&amp; typeof value.then === &quot;function&quot;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if (value &amp;&amp; typeof value.then === &quot;function&quot;)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then (callback) &#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let defer = () =&gt; &#123;</div><div class="line">    let pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value); // values wrapped in a promise</div><div class="line">                for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    let callback = pending[i];</div><div class="line">                    value.then(callback); // then called instead</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback) &#123;</div><div class="line">                let result = defer();</div><div class="line">                // callback is wrapped so that its return</div><div class="line">                // value is captured and used to resolve the promise</div><div class="line">                // that &quot;then&quot; returns</div><div class="line">                let callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push(callback);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let a = defer();</div><div class="line">a.promise.then(function(value)&#123;console.log(value);return 2&#125;).then(function(value)&#123;console.log(value)&#125;);</div><div class="line">a.resolve(1);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>将defer分为两个部分，一个是promise，一个是resolve</p>
</blockquote>
<p>到了这一步基本上的promise功能已经实现了，可以链式调用，可以在自己控制在未来某个时间resolve。接下去就是功能的增强和补足了。</p>
<p>这一块回调基本上就写完了，看了很久原文的描述，对着代码理解作者想表达的意思。不过英语不太好，写的磕磕绊绊。╮(╯▽╰)╭，感觉还是有些地方写的不对。希望有人能够纠错出来。</p>
<h4 id="五、提供错误的回调"><a href="#五、提供错误的回调" class="headerlink" title="五、提供错误的回调"></a>五、提供错误的回调</h4><p>为了实现错误消息的传递，我们还需要一个错误的回调函数(errback)。就像promise完全执行时调用callback一样，它会告知执行errback以及告诉我们拒绝的原因。</p>
<p>实现一个类似于前面ref的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let reject = (reason) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then(callback,errback)&#123;</div><div class="line">            return ref(errback(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最简单的实现方法是当监听到返回值时，立即执行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">reject(&quot;Meh.&quot;).then((value) =&gt; &#123;&#125;,(reason) =&gt; &#123;</div><div class="line">    throw new Error(reason);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么接下来我们改进原来promsie这个API，引入“errback”。</p>
<p>为了将错误回调添加到代码中，defer需要添加一种新的容器来添加成功回调和错误回调。因此之前那个存储在数组(pending)中的只有一种待处理回调函数，我们需要重新设计一个同时包含成功回调和错误回调的数组([callback,errback]),根据then传入的参数决定调用哪个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">var defer = function () &#123;</div><div class="line">    var pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value);</div><div class="line">                for (var i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    // apply the pending arguments to &quot;then&quot;</div><div class="line">                    value.then.apply(value, pending[i]);</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback, _errback) &#123;</div><div class="line">                var result = defer();</div><div class="line">                var callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                var errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback, errback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = (value) =&gt; &#123;</div><div class="line">    if (value &amp;&amp; typeof value.then === &quot;function&quot;)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback) &#123;</div><div class="line">            return ref(callback(value));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let reject = (reason) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback, errback) &#123;</div><div class="line">            return ref(errback(reason));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>代码写完了，但是仍然还有地方可以改进。</p>
<p>比如作者说到这一步有一个问题，就是如果按照上面这么写，那么所有的then函数就必须提供错误回调函数(_errback)，如果不提供就会出错。所以最简单的解决方法是提供一个默认的回调函数。甚至文中还说，如果仅仅是对错误回调有需要，那么忽略不写成功回调(_callback)也是可以的。所以为了满足需求，我们为_callback和_errback都提供一个默认的回调函数。（好吧，其实我就是觉得这是一个好的库的容错处理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">var defer = function () &#123;</div><div class="line">    ...</div><div class="line">    return&#123;</div><div class="line">        ...</div><div class="line">        promise : &#123;</div><div class="line">             then: function (_callback, _errback) &#123;</div><div class="line">                var result = defer();</div><div class="line">                // 提供一个默认的成功回调和错误回调</div><div class="line">                _callback = _callback || function (value) &#123;</div><div class="line">                    // 默认执行</div><div class="line">                    return value;</div><div class="line">                &#125;;</div><div class="line">                _errback = _errback || function (reason) &#123;</div><div class="line">                    // 默认拒绝</div><div class="line">                    return reject(reason);</div><div class="line">                &#125;;</div><div class="line">                var callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                var errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    value.then(callback, errback);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，现在我们已经实现了接收构造或者隐含的错误回调<a href="https://github.com/kriskowal/q/blob/v1/design/q6.js" target="_blank" rel="external">这一步的完成版</a></p>
<h4 id="六、安全性和稳定性"><a href="#六、安全性和稳定性" class="headerlink" title="六、安全性和稳定性"></a>六、安全性和稳定性</h4><p>我们还有需要需要提高的地方就是要保证callbacks和errbacks在未来他们被调用的时候，应该是和注册时的顺序是保持一致的。这将显著降低异步编程中流程控制出错可能性。文中举了一个有趣的小例子.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var blah = function () &#123;</div><div class="line">    var result = foob().then(function () &#123;</div><div class="line">        return barf();</div><div class="line">    &#125;);</div><div class="line">    var barf = function () &#123;</div><div class="line">        return 10;</div><div class="line">    &#125;;</div><div class="line">    return result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面这个函数在执行后会出现两种情况，一是抛出一个异常，二是顺利执行并返回了值10。而决定是哪个结果的是foob()是否在正确顺序里。因为我们希望哪怕回调在未来被延迟执行了，它能够执行成功。</p>
<p>下面添加了一个enqueue方法，我的理解就是依靠setTimeout的异步将所有回调按照顺序添加到任务队列中，保证按照顺序执行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">let enqueue = (callback) =&gt; &#123;</div><div class="line">    setTimeout(callback,1)</div><div class="line">&#125;</div><div class="line">let enqueue = (callback) =&gt; &#123;</div><div class="line">    //process.nextTick(callback); // NodeJS</div><div class="line">    setTimeout(callback, 1); // Naïve browser solution</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let defer = function () &#123;</div><div class="line">    let pending = [], value;</div><div class="line">    return &#123;</div><div class="line">        resolve: function (_value) &#123;</div><div class="line">            if (pending) &#123;</div><div class="line">                value = ref(_value);</div><div class="line">                for (let i = 0, ii = pending.length; i &lt; ii; i++) &#123;</div><div class="line">                    enqueue(function () &#123;</div><div class="line">                        value.then.apply(value, pending[i]);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                pending = undefined;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        promise: &#123;</div><div class="line">            then: function (_callback, _errback) &#123;</div><div class="line">                let result = defer();</div><div class="line">                _callback = _callback || function (value) &#123;</div><div class="line">                    return value;</div><div class="line">                &#125;;</div><div class="line">                _errback = _errback || function (reason) &#123;</div><div class="line">                    return reject(reason);</div><div class="line">                &#125;;</div><div class="line">                let callback = function (value) &#123;</div><div class="line">                    result.resolve(_callback(value));</div><div class="line">                &#125;;</div><div class="line">                let errback = function (reason) &#123;</div><div class="line">                    result.resolve(_errback(reason));</div><div class="line">                &#125;;</div><div class="line">                if (pending) &#123;</div><div class="line">                    pending.push([callback, errback]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    // XXX</div><div class="line">                    enqueue(function () &#123;</div><div class="line">                        value.then(callback, errback);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">                return result.promise;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let ref = function (value) &#123;</div><div class="line">    if (value &amp;&amp; value.then)</div><div class="line">        return value;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback) &#123;</div><div class="line">            let result = defer();</div><div class="line">            // XXX</div><div class="line">            enqueue(function () &#123;</div><div class="line">                result.resolve(callback(value));</div><div class="line">            &#125;);</div><div class="line">            return result.promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let reject = function (reason) &#123;</div><div class="line">    return &#123;</div><div class="line">        then: function (callback, errback) &#123;</div><div class="line">            var result = defer();</div><div class="line">            // XXX</div><div class="line">            enqueue(function () &#123;</div><div class="line">                result.resolve(errback(reason));</div><div class="line">            &#125;);</div><div class="line">            return result.promise;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>虽然将需要的回调依照次序添加到了队列中</p>
<p>作者有考虑到一些新的问题，比如</p>
<ul>
<li>callback或者errback必须以同样的顺序被调用</li>
<li>callback或者errback可能会被同时调用</li>
<li>callback或者errback可能会被调用多次</li>
</ul>
<p>于是我们需要找个机会then的回调函数，为了保证当回调函数中程序出错时，可以转入到报错函数中。(其实又是一个库的容错处理，保证代码出错时不中断程序的执行)。</p>
<p>用when方法封装下promise以此阻止错误发生，确保不会有哪些突发性的错误，包括哪些非必需的事件流控制，并且也能使callback和errback各自保持独立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">var when = function (value, _callback, _errback) &#123;</div><div class="line">    var result = defer();</div><div class="line">    var done;</div><div class="line"></div><div class="line">    _callback = _callback || function (value) &#123;</div><div class="line">        return value;</div><div class="line">    &#125;;</div><div class="line">    _errback = _errback || function (reason) &#123;</div><div class="line">        return reject(reason);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    var callback = function (value) &#123;</div><div class="line">        try &#123;</div><div class="line">            return _callback(value);</div><div class="line">        &#125; catch (reason) &#123;</div><div class="line">            return reject(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    var errback = function (reason) &#123;</div><div class="line">        try &#123;</div><div class="line">            return _errback(reason);</div><div class="line">        &#125; catch (reason) &#123;</div><div class="line">            return reject(reason);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    enqueue(function () &#123;</div><div class="line">        ref(value).then(function (value) &#123;</div><div class="line">            if (done)</div><div class="line">                return;</div><div class="line">            done = true;</div><div class="line">            result.resolve(ref(value).then(callback, errback));</div><div class="line">        &#125;, function (reason) &#123;</div><div class="line">            if (done)</div><div class="line">                return;</div><div class="line">            done = true;</div><div class="line">            result.resolve(errback(reason));</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return result.promise;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/kriskowal/q/blob/v1/design/q7.js" target="_blank" rel="external">这一步的完整版</a></p>
<h4 id="六、消息传递"><a href="#六、消息传递" class="headerlink" title="六、消息传递"></a>六、消息传递</h4><p>现在这一步来看，promise已经成为了一个具有接受消息功能的类了。Deferred promise根据获得的消息来执行对应的回调函数，返回对应的值。当你接收到完全成功执行的值，则在then中执行成功的回调函数返回msg；获得错误的值则在then中执行错误回调函数，返回错误的原因</p>
<p>因此我们基本可以认为promise这个类可以接受任何的值，包括”then/when”这些信息。这对于一些非立即执行函数的监听非常有用。举个例子，当你发了一个网络请求，等待返回值才能执行函数。我们等待这个请求的往返的过程中浪费了许多时间，而promise仿佛在电脑中另外开了一个线程进行监听这些返回值，然后执行对应的回调函数(这个例子是自己理解举的，非原文，如有不对，欢迎改正)。</p>
<blockquote>
<p>翻到这里有点崩溃了，捂下脑子，接下去感觉有点头疼了，以后再补吧,因为基本形态的promise已经出来。接下去是另外一种需求的promise了</p>
</blockquote>
<p>接下来我们要包装一种新型的promise，这套promise基于一些能发送任意消息的方法之上，可以满足 “get”, “put”, “post”能发送相应的消息，并且能根据返回结果中执行相应的promise。</p>
<hr>
<p>第一次尝试翻译，真的是个体力活，花了快2天的时间，整个人都是炸的。不过所幸是比以前明白了一些恭喜。<br>原文大概讲解了基本的promise构成，但是现在还是有许多方法并没有分析，接下去我按照自己的想法去实现以下promise.all方法。如果写的不好，欢迎大家指正，帮我进步一下，谢谢。（手动捂脸）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linzx">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="linzx">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/" itemprop="url">第十六章-站在巨人的肩膀</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-14T19:47:44+08:00">
                2017-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/《解释的工具-生活中的经济学原理》/" itemprop="url" rel="index">
                    <span itemprop="name">《解释的工具-生活中的经济学原理》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/08/14/16.生活中的经济学原理-----站在巨人的肩膀/" class="leancloud_visitors" data-flag-title="第十六章-站在巨人的肩膀">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  933
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  3
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="《解释的工具-生活中的经济学原理》"><a href="#《解释的工具-生活中的经济学原理》" class="headerlink" title="《解释的工具-生活中的经济学原理》"></a>《解释的工具-生活中的经济学原理》</h4><h6 id="—–第十六章-站在巨人的肩膀"><a href="#—–第十六章-站在巨人的肩膀" class="headerlink" title="—–第十六章-站在巨人的肩膀"></a>—–第十六章-站在巨人的肩膀</h6><p>这章也是本书的最后一章了，看到这里，我不禁问自己两个问题，1.站在经济学的角度，你是否有培养出抽象思考的能力，面对社会的各种现象，是否有一套自己的理论而不是依然人云亦云。2.站在了巨人肩膀上，你是否理解了经济学的思维呢。</p>
<p>第一章节对于人性的分析即生活经济学，让我明白了我们生活中很多不知不觉的习惯其实就是经济学思维的影响，理性与自利的人性，懒惰的天性，信任的价值都是生活中的经济哲学。</p>
<p>第二章的社会经济学则解释了许多社会想象的产生，冷漠的围观者，无情的竞争，残忍的管制都可以由经济学的成本分析。幸运的是，我还相信这中国会变得原来越好，而不是我再网上看到各种黑暗的地方。</p>
<p>第三章政治经济学解释了许多国家政策产生的原因以及我们普通人在这些政策之下受到的影响。无奈的是，虽然我明白了这些政策的最终方向，可是却无法改变自己在大潮下的走势。逆水行舟，不进则退啊。</p>
<p>第四章的法律经济学有时候看得我心惊胆战，世界上是否存在真正的公平与正义，你所看到的真的对的，有价值，有意义的吗？面对真正的选择，跳出自己所在的层面，站在更多更高的角度，也许会发现更多之前没有考虑到的，然后做出的取舍，才显得更加的“公平与正义”。</p>
<p>纵览全书，又人及社会及政治及法律，经济学有由小到大，由点及面，细细解析其所影响的各个层面。归纳出最后4点。</p>
<h5 id="1-人是理性的，自私的。"><a href="#1-人是理性的，自私的。" class="headerlink" title="1. 人是理性的，自私的。"></a>1. 人是理性的，自私的。</h5><p>人们是会思索判断的生物，大多数行为总是为了增添自己（或者自己周围人的福祉）。引申出来的许多懒惰的特性也是由此而来。</p>
<h5 id="2-存在不一定合理，但是存在一定是有原因的。"><a href="#2-存在不一定合理，但是存在一定是有原因的。" class="headerlink" title="2. 存在不一定合理，但是存在一定是有原因的。"></a>2. 存在不一定合理，但是存在一定是有原因的。</h5><p>正是因为行为都是基于理性和自私，所以近年来出现许多冷漠的社会现象（冷眼围观，碰瓷，污蔑）。这些社会现象的出现，都有背后条件的支持————存在不一定合理，但是存在一定是有原因的。</p>
<h5 id="3-好的价值要出现，是有条件的"><a href="#3-好的价值要出现，是有条件的" class="headerlink" title="3. 好的价值要出现，是有条件的"></a>3. 好的价值要出现，是有条件的</h5><p>每个人都希望自己有好的环境，事业上有好的发展，可是这必须你做出一些努力，父母朋友间的互动，自身努力获得好的经济等等。个人小的价值尚且需要这些努力，更大的价值当然需要更困难的条件来支持。所以说，好的价值的出现，是有条件的</p>
<h5 id="4-一件事物的意义，是由其他事物衬托出来的。"><a href="#4-一件事物的意义，是由其他事物衬托出来的。" class="headerlink" title="4. 一件事物的意义，是由其他事物衬托出来的。"></a>4. 一件事物的意义，是由其他事物衬托出来的。</h5><p>最后要说的是我们生活中许多隐含经济学的经验和原则，都是你所在相对环境形成的。如果环境发生改变，则你自己原先所认定的原则自然也会随之发生变化（你要学会拥抱变化）。因此事物的意义，是相对于环境里的各种主管条件，是相对的而不是绝对的。</p>
<p>观点在不断的变化，我们不断的在成长。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/header.jpg"
               alt="linzx" />
          <p class="site-author-name" itemprop="name">linzx</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/technology/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
    <div id="music163player">
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=406238&auto=0&height=66"></iframe>
        </iframe>
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">linzx</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("l3F7nF9MmsyTnvM5rI1g7V9s-gzGzoHsz", "TyY2L80HJkN4VjXnTqdDxuWw");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  <div class="bg_content">
      <canvas id="canvas"></canvas>
  </div>
  <script>
  'use strict';

      var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

      function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

      function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

      function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

      var Circle = function () {
         function Circle(x, y) {
              _classCallCheck(this, Circle);

              this.x = x;
              this.y = y;
              this.r = Math.random() * 10;
              this._mx = Math.random();
              this._my = Math.random();
          }

         _createClass(Circle, [{
              key: 'drawCircle',
              value: function drawCircle(ctx) {
                  ctx.beginPath();
                  //arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
                  ctx.arc(this.x, this.y, this.r, 0, 360);
                  ctx.closePath();
                  ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
                  ctx.fill();
              }
          }, {
              key: 'drawLine',
              value: function drawLine(ctx, _circle) {
                  var dx = this.x - _circle.x;
                  var dy = this.y - _circle.y;
                  var d = Math.sqrt(dx * dx + dy * dy);
                  if (d < 150) {
                      ctx.beginPath();

                      ctx.moveTo(this.x, this.y); //起始点
                      ctx.lineTo(_circle.x, _circle.y); //终点
                      ctx.closePath();
                      ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
                      ctx.stroke();
                  }
              }


          }, {
              key: 'move',
              value: function move(w, h) {
                  this._mx = this.x < w && this.x > 0 ? this._mx : -this._mx;
                  this._my = this.y < h && this.y > 0 ? this._my : -this._my;
                  this.x += this._mx / 2;
                  this.y += this._my / 2;
              }
          }]);

          return Circle;
      }();



      var currentCirle = function (_Circle) {
          _inherits(currentCirle, _Circle);

          function currentCirle(x, y) {
              _classCallCheck(this, currentCirle);

              return _possibleConstructorReturn(this, (currentCirle.__proto__ || Object.getPrototypeOf(currentCirle)).call(this, x, y));
          }

          _createClass(currentCirle, [{
              key: 'drawCircle',
              value: function drawCircle(ctx) {
                  ctx.beginPath();

                  //this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
                  this.r = 8;
                  ctx.arc(this.x, this.y, this.r, 0, 360);
                  ctx.closePath();
                  //ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
                  ctx.fillStyle = 'rgba(255, 77, 54, 0.6)';
                  ctx.fill();
              }
          }]);

          return currentCirle;
      }(Circle);


      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

      var canvas = document.getElementById('canvas');
      var ctx = canvas.getContext('2d');
      var w = canvas.width = canvas.offsetWidth;
      var h = canvas.height = canvas.offsetHeight;
      var circles = [];
      var current_circle = new currentCirle(0, 0);

      var draw = function draw() {
          ctx.clearRect(0, 0, w, h);
          for (var i = 0; i < circles.length; i++) {
              circles[i].move(w, h);
              circles[i].drawCircle(ctx);
              for (var j = i + 1; j < circles.length; j++) {
                  circles[i].drawLine(ctx, circles[j]);
              }
          }
          if (current_circle.x) {
              current_circle.drawCircle(ctx);
              for (var k = 1; k < circles.length; k++) {
                  current_circle.drawLine(ctx, circles[k]);
              }
          }
          requestAnimationFrame(draw);
      };

      var init = function init(num) {
          for (var i = 0; i < num; i++) {
              circles.push(new Circle(Math.random() * w, Math.random() * h));
          }
          draw();
      };
      window.addEventListener('load', init(60));
      window.onmousemove = function (e) {
          e = e || window.event;
          current_circle.x = e.clientX;
          current_circle.y = e.clientY;
      };
      window.onmouseout = function () {
          current_circle.x = null;
          current_circle.y = null;
      };
  </script>
</body>
</html>
